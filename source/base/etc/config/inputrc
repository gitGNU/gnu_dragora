# This file controls the behaviour of line input editing for
# programs that use the GNU Readline library.  Existing
# programs include FTP, Bash, and GDB.
#
# You can re-read the inputrc file with C-x C-r.
# Lines beginning with '#' are comments.

# In all programs, all terminals, make sure this is bound.
"\C-x\C-r": re-read-init-file

# Set various bindings for emacs mode.
set editing-mode emacs

$if mode=emacs

Meta-Control-h:	backward-kill-word	Text after the function name is ignored

#
# Arrow keys in keypad mode
#
#"\M-OD":        backward-char
#"\M-OC":        forward-char
#"\M-OA":        previous-history
#"\M-OB":        next-history
#
# Arrow keys in ANSI mode
#
"\M-[D":        backward-char
"\M-[C":        forward-char
"\M-[A":        previous-history
"\M-[B":        next-history
#
# Arrow keys in 8 bit keypad mode
#
#"\M-\C-OD":       backward-char
#"\M-\C-OC":       forward-char
#"\M-\C-OA":       previous-history
#"\M-\C-OB":       next-history
#
# Arrow keys in 8 bit ANSI mode
#
#"\M-\C-[D":       backward-char
#"\M-\C-[C":       forward-char
#"\M-\C-[A":       previous-history
#"\M-\C-[B":       next-history

C-q: quoted-insert

$endif

# An old-style binding.  This happens to be the default.
TAB: complete

# Macros that are convenient for shell interaction
$if Bash
# edit the path
"\C-xp": "PATH=${PATH}\e\C-e\C-a\ef\C-f"

# prepare to type a quoted word --
# insert open and close double quotes
# and move to just after the open quote
"\C-x\"": "\"\"\C-b"

# insert a backslash (testing backslash escapes
# in sequences and macros)
"\C-x\\": "\\"

# Quote the current or previous word
"\C-xq": "\eb\"\ef\""

# Add a binding to refresh the line, which is unbound
"\C-xr": redraw-current-line

# Edit variable on current line.
"\M-\C-v": "\C-a\C-k$\C-y\M-\C-e\C-a\C-y="
$endif

# use a visible bell if one is available
#
# none, visible or audible.
set bell-style none

# don't strip characters to 7 bits when reading
set input-meta on

# allow iso-latin1 characters to be inserted rather
# than converted to prefix-meta sequences
set convert-meta off

# display characters with the eighth bit set directly
# rather than as meta-prefixed characters
set output-meta on

# if there are more than 150 possible completions for
# a word, ask the user if he wants to see all of them
set completion-query-items 150

# For FTP
$if Ftp
"\C-xg": "get \M-?"
"\C-xt": "put \M-?"
"\M-.": yank-last-arg
$endif

# In xterm windows, make the arrow keys do the right thing.
$if TERM=xterm
"\e[A": previous-history
"\e[B": next-history
"\e[C": forward-char
"\e[D": backward-char

# on linux console
"\e[1~": beginning-of-line
"\e[4~": end-of-line
"\e[5~": beginning-of-history
"\e[6~": end-of-history
"\e[3~": delete-char
"\e[2~": quoted-insert

# alternate arrow key prefix
"\eOA": previous-history
"\eOB": next-history
"\eOC": forward-char
"\eOD": backward-char

# Under Xterm in Bash, we bind local Function keys to do something useful.
$if Bash
"\e[11~": "Function Key 1"
"\e[12~": "Function Key 2"
"\e[13~": "Function Key 3"
"\e[14~": "Function Key 4"
"\e[15~": "Function Key 5"

# I know the following escape sequence numbers are 1 greater than
# the function key.  Don't ask me why, I didn't design the xterm terminal.
"\e[17~": "Function Key 6"
"\e[18~": "Function Key 7"
"\e[19~": "Function Key 8"
"\e[20~": "Function Key 9"
"\e[21~": "Function Key 10"
$endif
$endif
