#!/bin/sh
#  Copyright (C) 2010-2011  Matias A. Fonzo, Santiago del Estero, Argentina
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <http://www.gnu.org/licenses/>.

# Usage:
#
# If you want to build all, type:
#   ./sdl-builder
#
# If you want to build a specific source, type:
#   ./sdl-builder SDL

# Variables #

# Iniciales:
currentWorkDir=$(pwd)                  # Directorio actual de trabajo.

tempDir=${tempDir:-/tmp}               # Directorio temporal base.
outDir=${outDir:-/tmp/packages/sdl}    # Directorio de salida de los paquetes.

buildDir=${tempDir}/sdl-buildir        # Directorio temporal de construcción.

# Variables de entorno:
CFLAGS=${CFLAGS:=-O2 -march=i486 -mtune=i686}
CXXFLAGS=${CXXFLAGS:=-O2 -march=i486 -mtune=i686}

libSuffix=${libSuffix:-""}             # Sufijo exportado usualmente para x86_64.

Arch=${Arch:-i486}                     # Arquitectura.
buildNum=${buildNum:-1}                # Número de construcción.

numJobs=${numJobs:=-j6}                # Trabajos para el compilador.

# Funciones #

# Una función para crear directorios limpios:
CreateDirs()
{
    local X Y
    X="$1"
    Y="$2"
    rm -rf $X
    mkdir -p $X $Y
}

## Cuerpo de la receta ##

set -e  # Sale ante cualquier error.

# Exportamos las variables de entorno:
export CFLAGS CXXFLAGS libSuffix

cd sources

for Source in \
  SDL SDL_image SDL_mixer SDL_net SDL_ttf
do
  # Comprueba el primer argumento:
  if [ -n "$1" ]; then
    if [ "$1" != $Source ]; then
      continue;
    fi
  fi

  # Variable del directorio del paquete (de toda una sección):
  packageDir=${buildDir}/package-${Source}

  for Tarball in ${Source}*.tar.lz ; do
    sourceName="$(basename $Tarball .tar.lz)"
    sourceVersion="${sourceName##*-}"
    sourceName="${sourceName%-*}"

    # Verifica la lista de las fuentes que poseen una arquitectura independiente:
    archPackage=$Arch  # Resetea la variable.
    if [ -r ${currentWorkDir}/NOARCHLIST ]; then
      if grep -qx "^${sourceName}" ${currentWorkDir}/NOARCHLIST ; then
        archPackage=noarch
      fi
    fi

    # Crea el directorio del paquete y el de salida:
    CreateDirs "$packageDir" "$outDir"

    cd $buildDir  # Hora de construir la fuente.

    # Descomprime una fuente:
    rm -rf ${sourceName}-${sourceVersion}
    lzip -cd ${currentWorkDir}/sources/$Tarball | tar -xvf -

    # Determina el número de construcción para el paquete. Según,
    # indicaciones en un archivo o de la variable ya establecida:
    buildNumPkg=$buildNum  # Resetea la variable.
    if [ -f ${currentWorkDir}/buildnum/$sourceName ]; then
      buildNumPkg=$(cut -f 1 -d ' ' ${currentWorkDir}/buildnum/${sourceName})
    fi

    # Ingresamos al directorio de la fuente:
    (
      cd ${sourceName}-${sourceVersion}*

      # Corregimos los permisos y el propiertario (si es necesario):
      chown -R 0:0 .
      find . \
       \( -perm 2777 -o -perm 777 -o -perm 775 -o -perm 711 -o -perm 555 -o -perm 511 \
       \) -exec chmod 755 {} + \
       -o \
       \( -perm 666 -o -perm 664 -o -perm 600 -o -perm 444 -o -perm 440 -o -perm 400 \
       \) -exec chmod 644 {} +

      # Determina el tipo de sistema donde se construye.
      if [ "$archPackage" != "noarch" ]; then
        BUILD_SYSTEM="--build=${Arch}-dragora-linux-gnu"
      fi

      # Si es necesario aplicamos un parche:
      if [ -x ${currentWorkDir}/patches/${sourceName} ]; then
        . ${currentWorkDir}/patches/${sourceName}
      fi

      # Si es necesario usamos un `configure' personalizado:
      if [ -f ${currentWorkDir}/configure/${sourceName} ]; then
        . ${currentWorkDir}/configure/${sourceName}
      else  # Usa el `configure' por defecto:
        . ${currentWorkDir}/configure/default
      fi

      # Tiempo de construir:
      make $numJobs || make
      make install DESTDIR=$packageDir

      # Purgamos los binarios y las librerías para una buena medida:
      ( cd $packageDir
        find . -type f | xargs file | awk '/ELF/ && /executable/ || /shared object/' | \
         cut -f 1 -d : | xargs strip --strip-unneeded 2> /dev/null || :
        find . -type f | xargs file | awk '/current ar archive/' | \
         cut -f 1 -d : | xargs strip --strip-debug 2> /dev/null || :
      )

      # Si es necesario recurrimos a pasos adicionales:
      if [ -x "${currentWorkDir}/postmake/${sourceName}" ]; then
        . "${currentWorkDir}/postmake/${sourceName}"
      fi

      # Comprimimos, enlazamos y copiamos para el resto de nuestro paquete:
      cd $packageDir

      # Arregla la ruta del directorio de documentación (si es necesario):
      #
      # Movemos los directorios de documentación puesto que
      # no queremos dichos directorios bajo usr/share:
      for Directory in man info doc ; do
        if [ -d usr/share/${Directory} ]; then
          mv usr/share/${Directory} usr/${Directory}
        fi
      done
      rmdir usr/share 2> /dev/null || :

      # Comprime las páginas de información (si hay alguna):
      if [ -d usr/info ]; then
        rm -f usr/info/dir  # Redundancia.
        gzip -9Nf usr/info/*
      fi

      # Comprime y enlaza las páginas de manual (si hay alguna):
      if [ -d usr/man ]; then
        ( cd usr/man
          find . -type f -exec gzip -9N '{}' +
          find . -type l | while read File ; do
            ln -sf $(readlink $File).gz ${File}.gz
            rm $File
          done
        )
      fi

      # Crea el directorio de documentación y busca para copiar los archivos:
      mkdir -p usr/doc/${sourceName}-${sourceVersion}
      for File in \
       AUTHORS COPYING* ChangeLog NEWS README TODO CREDITS README-SDL* WhatsNew BUGS docs.html
      do
        if [ -f "${buildDir}/${sourceName}-${sourceVersion}/$File" ]; then
          cp -pP \
           ${buildDir}/${sourceName}-${sourceVersion}/$File \
           usr/doc/${sourceName}-${sourceVersion}
        fi
      done
      # Algunas fuentes instalan el directorio de documentación con sólo el
      # nombre de la fuente.  Cuando nosotros, lo que queremos, es tener el
      # directorio de documentación bajo <nombre_programa>-<versión>:
      if [ -d ${packageDir}/usr/doc/${sourceName} ]; then
        for file in ${packageDir}/usr/doc/${sourceName}/* ; do
          if [ -f "$file" ]; then
            mv "$file" usr/doc/${sourceName}-${sourceVersion}
          fi
        done
        rmdir ${packageDir}/usr/doc/${sourceName} 2> /dev/null || :
      fi

      # Introducimos los archivos de descripción:
      if [ -d ${currentWorkDir}/descriptions/$sourceName ]; then
        mkdir -p description/
        cp ${currentWorkDir}/descriptions/${sourceName}/* ${packageDir}/description/
      else  # Reportar descripción perdida:
        echo "$sourceName" >> ${currentWorkDir}/missing.descriptions
      fi

      sourceName=$(printf "$sourceName" | tr A-Z a-z)

      # Hacemos el paquete:
      if [ -x ${currentWorkDir}/makepkg/$sourceName ]; then
        . ${currentWorkDir}/makepkg/$sourceName
      else
        makepkg -l \
         ${outDir}/${sourceName}-${sourceVersion}-${archPackage}-${buildNumPkg}.tlz
      fi

      # Actualiza el paquete si la variable UP es exportada:
      if [ "$UP" != "" ]; then
        /sbin/pkg \
         upgrade ${outDir}/${sourceName}-${sourceVersion}-${archPackage}-${buildNumPkg}.tlz
      fi
    )
    cd - >/dev/null
    break;
  done
done

