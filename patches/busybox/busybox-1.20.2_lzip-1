diff -urdN busybox-1.20.2.orig/archival/Config.src busybox-1.20.2.new/archival/Config.src
--- busybox-1.20.2.orig/archival/Config.src	2012-06-26 15:35:45.000000000 +0200
+++ busybox-1.20.2.new/archival/Config.src	2012-12-07 18:12:58.000000000 +0100
@@ -31,6 +31,12 @@
 	help
 	  Make tar, rpm, modprobe etc understand .gz data.
 
+config FEATURE_SEAMLESS_LZ
+	bool "Make tar, rpm, modprobe etc understand .lz data"
+	default y
+	help
+	  Make tar, rpm, modprobe etc understand .lz data.
+
 config FEATURE_SEAMLESS_Z
 	bool "tar, rpm, modprobe etc understand .Z data"
 	default n
@@ -199,6 +205,24 @@
 	  2: larger buffers, largest hash-tables
 	  Larger models may give slightly better compression
 
+config LUNZIP
+	bool "lunzip"
+	default y
+	help
+	  lunzip is used to decompress archives created by lzip.
+	  You can use the `-t' option to test the integrity of
+	  an archive, without decompressing it.
+
+config LZIP
+	bool "lzip"
+	default y
+	help
+	  Lzip is a lossless data compressor based on the LZMA algorithm, with
+	  very safe integrity checking and a user interface similar to the one
+	  of gzip or bzip2. Lzip decompresses almost as fast as gzip and
+	  compresses better than bzip2, which makes it well suited for software
+	  distribution and data archiving.
+
 config LZOP
 	bool "lzop"
 	default y
@@ -245,7 +269,7 @@
 config FEATURE_TAR_AUTODETECT
 	bool "Autodetect compressed tarballs"
 	default y
-	depends on TAR && (FEATURE_SEAMLESS_Z || FEATURE_SEAMLESS_GZ || FEATURE_SEAMLESS_BZ2 || FEATURE_SEAMLESS_LZMA || FEATURE_SEAMLESS_XZ)
+	depends on TAR && (FEATURE_SEAMLESS_Z || FEATURE_SEAMLESS_GZ || FEATURE_SEAMLESS_BZ2 || FEATURE_SEAMLESS_LZ || FEATURE_SEAMLESS_LZMA || FEATURE_SEAMLESS_XZ)
 	help
 	  With this option tar can automatically detect compressed
 	  tarballs. Currently it works only on files (not pipes etc).
diff -urdN busybox-1.20.2.orig/archival/Kbuild.src busybox-1.20.2.new/archival/Kbuild.src
--- busybox-1.20.2.orig/archival/Kbuild.src	2012-06-26 15:35:45.000000000 +0200
+++ busybox-1.20.2.new/archival/Kbuild.src	2012-12-07 18:12:58.000000000 +0100
@@ -22,9 +22,11 @@
 lib-$(CONFIG_LZOP)		+= lzop.o bbunzip.o
 lib-$(CONFIG_GZIP)		+= gzip.o bbunzip.o
 lib-$(CONFIG_BZIP2)		+= bzip2.o bbunzip.o
+lib-$(CONFIG_LZIP)		+= lzip.o bbunzip.o
 
 lib-$(CONFIG_UNXZ)		+= bbunzip.o
 lib-$(CONFIG_UNLZMA)		+= bbunzip.o
 lib-$(CONFIG_BUNZIP2)		+= bbunzip.o
 lib-$(CONFIG_GUNZIP)		+= bbunzip.o
+lib-$(CONFIG_LUNZIP)		+= bbunzip.o
 lib-$(CONFIG_UNCOMPRESS)	+= bbunzip.o
diff -urdN busybox-1.20.2.orig/archival/bbunzip.c busybox-1.20.2.new/archival/bbunzip.c
--- busybox-1.20.2.orig/archival/bbunzip.c	2012-06-26 15:35:45.000000000 +0200
+++ busybox-1.20.2.new/archival/bbunzip.c	2012-12-07 18:12:58.000000000 +0100
@@ -151,17 +151,29 @@
 	return exitcode;
 }
 
-#if ENABLE_UNCOMPRESS || ENABLE_BUNZIP2 || ENABLE_UNLZMA || ENABLE_UNXZ
+#if ENABLE_UNCOMPRESS || ENABLE_BUNZIP2 || ENABLE_LUNZIP || ENABLE_UNLZMA || ENABLE_UNXZ
 static
 char* FAST_FUNC make_new_name_generic(char *filename, const char *expected_ext)
 {
 	char *extension = strrchr(filename, '.');
-	if (!extension || strcmp(extension + 1, expected_ext) != 0) {
+
+	if (!extension)
+		return NULL;
+
+	if (strcmp(extension + 1, expected_ext) == 0) {
+		*extension = '\0';
+	} else if (extension[1] == 't' && strlen(expected_ext) >= 2 &&
+			strcmp(extension + 2, expected_ext) == 0) {
+		filename = xstrdup(filename);
+		extension = strrchr(filename, '.');
+		extension[2] = 'a';
+		extension[3] = 'r';
+		extension[4] = '\0';
+	} else {
 		/* Mimic GNU gunzip - "real" bunzip2 tries to */
 		/* unpack file anyway, to file.out */
 		return NULL;
 	}
-	*extension = '\0';
 	return filename;
 }
 #endif
@@ -340,6 +352,30 @@
 #endif
 
 
+//usage:#define lunzip_trivial_usage
+//usage:       "[-cft] [FILE]..."
+//usage:#define lunzip_full_usage "\n\n"
+//usage:       "Decompress FILEs (or stdin)\n"
+//usage:     "\n	-c	Write to stdout"
+//usage:     "\n	-f	Force"
+//usage:     "\n	-t	Test file integrity"
+#if ENABLE_LUNZIP
+static
+IF_DESKTOP(long long) int FAST_FUNC unpack_lunzip(transformer_aux_data_t *aux)
+{
+	return unpack_lz_stream(aux, STDIN_FILENO, STDOUT_FILENO);
+}
+int lunzip_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
+int lunzip_main(int argc UNUSED_PARAM, char **argv)
+{
+	getopt32(argv, "cfvdt");
+	argv += optind;
+
+	return bbunpack(argv, unpack_lunzip, make_new_name_generic, "lz");
+}
+#endif
+
+
 /*
  * Small lzma deflate implementation.
  * Copyright (C) 2006  Aurelien Jacobs <aurel@gnuage.org>
diff -urdN busybox-1.20.2.orig/archival/libarchive/Kbuild.src busybox-1.20.2.new/archival/libarchive/Kbuild.src
--- busybox-1.20.2.orig/archival/libarchive/Kbuild.src	2012-06-26 15:35:45.000000000 +0200
+++ busybox-1.20.2.new/archival/libarchive/Kbuild.src	2012-12-07 18:12:58.000000000 +0100
@@ -34,6 +34,7 @@
 	get_header_tar.o \
 	get_header_tar_gz.o \
 	get_header_tar_bz2.o \
+	get_header_tar_lz.o \
 	get_header_tar_lzma.o \
 
 INSERT
@@ -46,6 +47,7 @@
 lib-$(CONFIG_DPKG)                      += $(DPKG_FILES)
 lib-$(CONFIG_DPKG_DEB)                  += $(DPKG_FILES)
 lib-$(CONFIG_GUNZIP)                    += open_transformer.o decompress_gunzip.o
+lib-$(CONFIG_LUNZIP)                    += decompress_lunzip.o
 lib-$(CONFIG_RPM2CPIO)                  += decompress_gunzip.o get_header_cpio.o
 lib-$(CONFIG_RPM)                       += open_transformer.o decompress_gunzip.o get_header_cpio.o
 lib-$(CONFIG_TAR)                       += get_header_tar.o
@@ -58,6 +60,7 @@
 lib-$(CONFIG_FEATURE_SEAMLESS_Z)        += open_transformer.o decompress_uncompress.o
 lib-$(CONFIG_FEATURE_SEAMLESS_GZ)       += open_transformer.o decompress_gunzip.o
 lib-$(CONFIG_FEATURE_SEAMLESS_BZ2)      += open_transformer.o decompress_bunzip2.o
+lib-$(CONFIG_FEATURE_SEAMLESS_LZ)       += open_transformer.o decompress_lunzip.o
 lib-$(CONFIG_FEATURE_SEAMLESS_LZMA)     += open_transformer.o decompress_unlzma.o
 lib-$(CONFIG_FEATURE_SEAMLESS_XZ)       += open_transformer.o decompress_unxz.o
 lib-$(CONFIG_FEATURE_COMPRESS_USAGE)    += open_transformer.o decompress_bunzip2.o
diff -urdN busybox-1.20.2.orig/archival/libarchive/decompress_lunzip.c busybox-1.20.2.new/archival/libarchive/decompress_lunzip.c
--- busybox-1.20.2.orig/archival/libarchive/decompress_lunzip.c	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.20.2.new/archival/libarchive/decompress_lunzip.c	2012-12-07 18:12:58.000000000 +0100
@@ -0,0 +1,572 @@
+/*
+ * lunzip implementation for busybox
+ *
+ * Copyright (C) 2012 Antonio Diaz Diaz <ant_diaz@teleline.es>
+ *
+ * Licensed under GPLv2 or later, see file LICENSE in this source tree.
+ */
+
+#include "libbb.h"
+#include "bb_archive.h"
+#include "lzip.h"
+
+
+enum { rd_buffer_size = 16384 };
+
+struct Range_decoder {
+	long long partial_member_pos;
+	uint8_t *buffer;	/* input buffer */
+	int pos;		/* current pos in buffer */
+	int stream_pos;		/* when reached, a new block must be read */
+	uint32_t code;
+	uint32_t range;
+	int infd;		/* input file descriptor */
+	bool at_stream_end;
+};
+
+
+static bool Rd_init(struct Range_decoder *const rdec, const int ifd,
+						const bool preload_magic)
+{
+	rdec->partial_member_pos = (preload_magic ? 4 : 0);
+	rdec->buffer = (uint8_t *) malloc(rd_buffer_size);
+	if (!rdec->buffer)
+		return false;
+	rdec->pos = 0;
+	rdec->stream_pos = 0;
+	rdec->code = 0;
+	rdec->range = 0xFFFFFFFFU;
+	rdec->infd = ifd;
+	rdec->at_stream_end = false;
+	return true;
+}
+
+static void Rd_free(struct Range_decoder *const rdec)
+{
+	free(rdec->buffer);
+}
+
+
+static bool Rd_read_block(struct Range_decoder *const rdec)
+{
+	if (!rdec->at_stream_end) {
+		rdec->stream_pos =
+			full_read(rdec->infd, rdec->buffer, rd_buffer_size);
+		rdec->at_stream_end = (rdec->stream_pos < rd_buffer_size);
+		rdec->partial_member_pos += rdec->pos;
+		rdec->pos = 0;
+	}
+	return rdec->pos < rdec->stream_pos;
+}
+
+
+static bool Rd_finished(struct Range_decoder *const rdec)
+{
+	return rdec->pos >= rdec->stream_pos && !Rd_read_block(rdec);
+}
+
+static long long Rd_member_position(const struct Range_decoder *const rdec)
+{
+	return rdec->partial_member_pos + rdec->pos;
+}
+
+static void Rd_reset_member_position(struct Range_decoder *const rdec)
+{
+	rdec->partial_member_pos = -rdec->pos;
+}
+
+static uint8_t Rd_get_byte(struct Range_decoder *const rdec)
+{
+	if (Rd_finished(rdec))
+		return 0xAA;	/* make code != 0 */
+	return rdec->buffer[rdec->pos++];
+}
+
+static void Rd_load(struct Range_decoder *const rdec)
+{
+	int i;
+
+	rdec->code = 0;
+	for (i = 0; i < 5; ++i)
+		rdec->code = (rdec->code << 8) | Rd_get_byte(rdec);
+	rdec->range = 0xFFFFFFFFU;
+}
+
+static void Rd_normalize(struct Range_decoder *const rdec)
+{
+	if (rdec->range <= 0x00FFFFFFU) {
+		rdec->range <<= 8;
+		rdec->code = (rdec->code << 8) | Rd_get_byte(rdec);
+	}
+}
+
+static int Rd_decode(struct Range_decoder *const rdec,
+						const int num_bits)
+{
+	int symbol = 0;
+	int i;
+
+	for (i = num_bits; i > 0; --i) {
+		symbol <<= 1;
+		if (rdec->range <= 0x00FFFFFFU) {
+			rdec->range <<= 7;
+			rdec->code = (rdec->code << 8) | Rd_get_byte(rdec);
+			if (rdec->code >= rdec->range) {
+				rdec->code -= rdec->range;
+				symbol |= 1;
+			}
+		} else {
+			rdec->range >>= 1;
+			if (rdec->code >= rdec->range) {
+				rdec->code -= rdec->range;
+				symbol |= 1;
+			}
+		}
+	}
+	return symbol;
+}
+
+static int Rd_decode_bit(struct Range_decoder *const rdec,
+					Bit_model * const probability)
+{
+	uint32_t bound;
+
+	Rd_normalize(rdec);
+	bound = (rdec->range >> bit_model_total_bits) * *probability;
+	if (rdec->code < bound) {
+		rdec->range = bound;
+		*probability +=
+			(bit_model_total - *probability) >> bit_model_move_bits;
+		return 0;
+	} else {
+		rdec->range -= bound;
+		rdec->code -= bound;
+		*probability -= *probability >> bit_model_move_bits;
+		return 1;
+	}
+}
+
+static int Rd_decode_tree(struct Range_decoder *const rdec,
+				Bit_model bm[], const int num_bits)
+{
+	int model = 1;
+	int i;
+
+	for (i = num_bits; i > 0; --i)
+		model = (model << 1) | Rd_decode_bit(rdec, &bm[model]);
+	return model - (1 << num_bits);
+}
+
+static int Rd_decode_tree_reversed(struct Range_decoder *const rdec,
+					Bit_model bm[], const int num_bits)
+{
+	int model = 1;
+	int symbol = 0;
+	int i;
+
+	for (i = 0; i < num_bits; ++i) {
+		const int bit = Rd_decode_bit(rdec, &bm[model]);
+
+		model <<= 1;
+		if (bit) {
+			model |= 1;
+			symbol |= (1 << i);
+		}
+	}
+	return symbol;
+}
+
+static int Rd_decode_matched(struct Range_decoder *const rdec,
+					Bit_model bm[], const int match_byte)
+{
+	Bit_model *const bm1 = bm + 0x100;
+	int symbol = 1;
+	int i;
+
+	for (i = 7; i >= 0; --i) {
+		const int match_bit = (match_byte >> i) & 1;
+
+		const int bit = Rd_decode_bit(rdec, &bm1[(match_bit << 8) + symbol]);
+
+		symbol = (symbol << 1) | bit;
+		if (match_bit != bit) {
+			while (--i >= 0)
+				symbol = (symbol << 1) | Rd_decode_bit(rdec, &bm[symbol]);
+			break;
+		}
+	}
+	return symbol & 0xFF;
+}
+
+
+struct Len_decoder {
+	Bit_model choice1;
+	Bit_model choice2;
+	Bit_model bm_low[pos_states][len_low_symbols];
+	Bit_model bm_mid[pos_states][len_mid_symbols];
+	Bit_model bm_high[len_high_symbols];
+};
+
+static void Led_init(struct Len_decoder *const len_decoder)
+{
+	Bm_init(&len_decoder->choice1);
+	Bm_init(&len_decoder->choice2);
+	Bm_array_init(&len_decoder->bm_low[0][0], len_num_models);
+}
+
+static int Led_decode(struct Len_decoder *const len_decoder,
+				struct Range_decoder *const rdec,
+				const int pos_state)
+{
+	if (Rd_decode_bit(rdec, &len_decoder->choice1) == 0)
+		return Rd_decode_tree(rdec, len_decoder->bm_low[pos_state],
+							len_low_bits);
+	if (Rd_decode_bit(rdec, &len_decoder->choice2) == 0)
+		return len_low_symbols +
+			Rd_decode_tree(rdec, len_decoder->bm_mid[pos_state],
+						len_mid_bits);
+	return len_low_symbols + len_mid_symbols + Rd_decode_tree(rdec,
+				len_decoder->bm_high, len_high_bits);
+}
+
+
+struct LZ_decoder {
+	long long partial_data_pos;
+	int buffer_size;	/* buffer_size == dictionary_size */
+	uint8_t *buffer;	/* output buffer */
+	int pos;		/* current pos in buffer */
+	int stream_pos;		/* first byte not yet written to file */
+	uint32_t crc;
+	int outfd;		/* output file descriptor */
+
+	Bit_model bm_literal[1 << literal_context_bits][0x300];
+	Bit_model bm_match[states][pos_states];
+	Bit_model bm_rep[states];
+	Bit_model bm_rep0[states];
+	Bit_model bm_rep1[states];
+	Bit_model bm_rep2[states];
+	Bit_model bm_len[states][pos_states];
+	Bit_model bm_dis_slot[max_dis_states][1 << dis_slot_bits];
+	Bit_model bm_dis[modeled_distances - end_dis_model + 1];
+	Bit_model bm_align[dis_align_size];
+
+	struct Range_decoder *range_decoder;
+	struct Len_decoder len_decoder;
+	struct Len_decoder rep_match_len_decoder;
+};
+
+static bool LZd_init(struct LZ_decoder *const decoder,
+			const int dictionary_size,
+			struct Range_decoder *const rdec, const int ofd)
+{
+	decoder->partial_data_pos = 0;
+	decoder->buffer_size = dictionary_size;
+	decoder->buffer = (uint8_t *) malloc(decoder->buffer_size);
+	if (!decoder->buffer)
+		return false;
+	decoder->pos = 0;
+	decoder->stream_pos = 0;
+	decoder->crc = 0xFFFFFFFFU;
+	decoder->outfd = ofd;
+
+	Bm_array_init(&decoder->bm_literal[0][0], lz_num_models);
+
+	decoder->range_decoder = rdec;
+	Led_init(&decoder->len_decoder);
+	Led_init(&decoder->rep_match_len_decoder);
+	decoder->buffer[decoder->buffer_size - 1] = 0;	/* prev_byte of first_byte */
+	return true;
+}
+
+static void LZd_free(struct LZ_decoder *const decoder)
+{
+	free(decoder->buffer);
+}
+
+static uint32_t LZd_crc(const struct LZ_decoder *const decoder)
+{
+	return decoder->crc ^ 0xFFFFFFFFU;
+}
+
+static long long LZd_data_position(const struct LZ_decoder *const decoder)
+{
+	return decoder->partial_data_pos + decoder->pos;
+}
+
+static bool LZd_flush_data(struct LZ_decoder *const decoder)
+{
+	const int size = decoder->pos - decoder->stream_pos;
+
+	if (size > 0) {
+		decoder->crc = crc32_block_endian0(decoder->crc,
+				decoder->buffer + decoder->stream_pos,
+				size, global_crc32_table);
+		if (decoder->outfd >= 0
+			&& full_write(decoder->outfd,
+				decoder->buffer + decoder->stream_pos,
+				size) != size)
+			return false;
+		if (decoder->pos >= decoder->buffer_size) {
+			decoder->partial_data_pos += decoder->pos;
+			decoder->pos = 0;
+		}
+		decoder->stream_pos = decoder->pos;
+	}
+	return true;
+}
+
+
+static uint8_t LZd_get_prev_byte(const struct LZ_decoder *const decoder)
+{
+	const int i =
+		((decoder->pos > 0) ? decoder->pos : decoder->buffer_size) - 1;
+	return decoder->buffer[i];
+}
+
+static uint8_t LZd_get_byte(const struct LZ_decoder *const decoder,
+						const int distance)
+{
+	int i = decoder->pos - distance - 1;
+
+	if (i < 0)
+		i += decoder->buffer_size;
+	return decoder->buffer[i];
+}
+
+static void LZd_put_byte(struct LZ_decoder *const decoder, const uint8_t b)
+{
+	decoder->buffer[decoder->pos] = b;
+	if (++decoder->pos >= decoder->buffer_size)
+		LZd_flush_data(decoder);
+}
+
+static void LZd_copy_block(struct LZ_decoder *const decoder,
+					const int distance, int len)
+{
+	int i = decoder->pos - distance - 1;
+
+	if (i < 0)
+		i += decoder->buffer_size;
+	if (len < decoder->buffer_size - MAX(decoder->pos, i) && len <= abs(decoder->pos - i)) {
+		/* no wrap, no overlap */
+		memcpy(decoder->buffer + decoder->pos, decoder->buffer + i, len);
+		decoder->pos += len;
+	} else
+		for (; len > 0; --len) {
+			decoder->buffer[decoder->pos] = decoder->buffer[i];
+			if (++decoder->pos >= decoder->buffer_size)
+				LZd_flush_data(decoder);
+			if (++i >= decoder->buffer_size)
+				i = 0;
+		}
+}
+
+
+static bool LZd_verify_trailer(struct LZ_decoder *const decoder)
+{
+	File_trailer trailer;
+	int i = 0;
+	while (i < Ft_size)
+		trailer[i++] = Rd_get_byte(decoder->range_decoder);
+
+	return (decoder->range_decoder->code == 0 &&
+		Ft_get_data_crc(trailer) == LZd_crc(decoder) &&
+		Ft_get_data_size(trailer) == LZd_data_position(decoder) &&
+		Ft_get_member_size(trailer) == Rd_member_position(decoder->range_decoder));
+}
+
+
+/* Return value: -1 = write error, 0 = OK, 1 = data error. */
+static int LZd_decode_member(struct LZ_decoder *const decoder)
+{
+	unsigned rep0 = 0;	/* rep[0-3] latest four distances */
+	unsigned rep1 = 0;	/* used for efficient coding of */
+	unsigned rep2 = 0;	/* repeated distances */
+	unsigned rep3 = 0;
+	State state = 0;
+
+	Rd_load(decoder->range_decoder);
+
+	while (!Rd_finished(decoder->range_decoder)) {
+		const int pos_state = LZd_data_position(decoder) & pos_state_mask;
+
+		if (Rd_decode_bit
+			(decoder->range_decoder,
+			&decoder->bm_match[state][pos_state]) == 0) {
+			const uint8_t prev_byte = LZd_get_prev_byte(decoder);
+
+			if (St_is_char(state)) {
+				state -= (state < 4) ? state : 3;
+				LZd_put_byte(decoder, Rd_decode_tree(decoder->range_decoder,
+						decoder->bm_literal[get_lit_state(prev_byte)], 8));
+			} else {
+				state -= (state < 10) ? 3 : 6;
+				LZd_put_byte(decoder, Rd_decode_matched(decoder->range_decoder,
+						decoder->bm_literal[get_lit_state(prev_byte)],
+						LZd_get_byte(decoder, rep0)));
+			}
+		} else {
+			int len;
+
+			if (Rd_decode_bit(decoder->range_decoder, &decoder->bm_rep[state]) == 1) {
+				len = 0;
+				if (Rd_decode_bit
+					(decoder->range_decoder, &decoder->bm_rep0[state]) == 1) {
+					unsigned distance;
+
+					if (Rd_decode_bit
+						(decoder->range_decoder,
+						&decoder->bm_rep1[state]) == 0)
+						distance = rep1;
+					else {
+						if (Rd_decode_bit
+							(decoder->range_decoder,
+							&decoder->bm_rep2[state]) == 0)
+							distance = rep2;
+						else {
+							distance = rep3;
+							rep3 = rep2;
+						}
+						rep2 = rep1;
+					}
+					rep1 = rep0;
+					rep0 = distance;
+				} else {
+					if (Rd_decode_bit
+						(decoder->range_decoder,
+						&decoder->bm_len[state][pos_state]) == 0) {
+						state = St_set_short_rep(state);
+						len = 1;
+					}
+				}
+				if (len == 0) {
+					state = St_set_rep(state);
+					len = min_match_len +
+						Led_decode(&decoder->rep_match_len_decoder,
+							decoder->range_decoder, pos_state);
+				}
+			} else {
+				int dis_slot;
+				const unsigned rep0_saved = rep0;
+
+				len = min_match_len + Led_decode(&decoder->len_decoder,
+						decoder->range_decoder, pos_state);
+				dis_slot = Rd_decode_tree(decoder->range_decoder,
+						decoder->bm_dis_slot[get_dis_state(len)], 6);
+				if (dis_slot < start_dis_model)
+					rep0 = dis_slot;
+				else {
+					const int direct_bits = (dis_slot >> 1) - 1;
+
+					rep0 = (2 | (dis_slot & 1)) << direct_bits;
+					if (dis_slot < end_dis_model)
+						rep0 += Rd_decode_tree_reversed(decoder->range_decoder,
+							decoder->bm_dis + rep0 -
+							dis_slot, direct_bits);
+					else {
+						rep0 +=	Rd_decode(decoder->range_decoder,
+									direct_bits - dis_align_bits) << dis_align_bits;
+						rep0 += Rd_decode_tree_reversed(decoder->range_decoder,
+									decoder->bm_align, dis_align_bits);
+						if (rep0 == 0xFFFFFFFFU) {	/* Marker found */
+							rep0 = rep0_saved;
+							Rd_normalize(decoder->range_decoder);
+							if (!LZd_flush_data(decoder))
+								return -1;
+							if (len == min_match_len &&	/* End Of Stream marker */
+								LZd_verify_trailer(decoder))
+								return 0;
+							if (len == min_match_len + 1) {	/* Sync Flush marker */
+								Rd_load(decoder->range_decoder);
+								continue;
+							}
+							return 1;
+						}
+					}
+				}
+				rep3 = rep2;
+				rep2 = rep1;
+				rep1 = rep0_saved;
+				state = St_set_match(state);
+				if (rep0 >= (unsigned) decoder->buffer_size ||
+					(rep0 >= (unsigned) decoder->pos
+					&& !decoder->partial_data_pos)) {
+					LZd_flush_data(decoder);
+					return 1;
+				}
+			}
+			LZd_copy_block(decoder, rep0, len);
+		}
+	}
+	LZd_flush_data(decoder);
+	return 1;
+}
+
+
+IF_DESKTOP(long long) int FAST_FUNC
+unpack_lz_stream(transformer_aux_data_t *aux, int src_fd, int dst_fd)
+{
+	IF_DESKTOP(long long) int total = 0;
+	struct Range_decoder rdec;
+	bool first_member;
+	const bool preload_magic = (!aux || aux->check_signature == 0);
+
+	if (!global_crc32_table)
+		global_crc32_table = crc32_filltable(NULL, 0);
+
+	if (!Rd_init(&rdec, src_fd, preload_magic))
+		return -1;
+
+	for (first_member = true;; first_member = false) {
+		int tmp = 0;
+		File_header header;
+		struct LZ_decoder * decoder;
+
+		if (first_member && preload_magic) {
+			Fh_set_magic(header);
+			tmp = 4;
+		} else {
+			Rd_reset_member_position(&rdec);
+		}
+		while (tmp < Fh_size)
+			header[tmp++] = Rd_get_byte(&rdec);
+		if (Rd_finished(&rdec)) {	/* End Of File */
+			if (first_member) {
+				bb_error_msg(bb_msg_read_error);
+				total = -1;
+			}
+			break;
+		}
+		tmp = Fh_get_dictionary_size(header);
+		if (!Fh_verify_magic(header) || tmp < min_dictionary_size ||
+			tmp > max_dictionary_size) {
+			if (!first_member)
+				break;		/* trailing garbage */
+			bb_error_msg("invalid magic");
+			total = -1;
+			break;
+		}
+
+		decoder = malloc(sizeof(struct LZ_decoder));
+		if (!decoder || !LZd_init(decoder, tmp, &rdec, dst_fd)) {
+			bb_error_msg(bb_msg_memory_exhausted);
+			free(decoder);
+			total = -1;
+			break;
+		}
+		tmp = LZd_decode_member(decoder);
+		IF_DESKTOP(total += Rd_member_position(&rdec);)
+		LZd_free(decoder);
+		free(decoder);
+		if (tmp != 0) {
+			if (tmp < 0)
+				bb_perror_msg(bb_msg_write_error);
+			else
+				bb_error_msg("corrupted data");
+			total = -1;
+			break;
+		}
+	}
+	Rd_free(&rdec);
+	return total;
+}
diff -urdN busybox-1.20.2.orig/archival/libarchive/filter_accept_list_reassign.c busybox-1.20.2.new/archival/libarchive/filter_accept_list_reassign.c
--- busybox-1.20.2.orig/archival/libarchive/filter_accept_list_reassign.c	2012-06-26 15:35:45.000000000 +0200
+++ busybox-1.20.2.new/archival/libarchive/filter_accept_list_reassign.c	2012-12-07 18:12:58.000000000 +0100
@@ -40,6 +40,12 @@
 			archive_handle->dpkg__action_data_subarchive = get_header_tar_bz2;
 			return EXIT_SUCCESS;
 		}
+		if (ENABLE_FEATURE_SEAMLESS_LZ
+		 && strcmp(name_ptr, "lz") == 0
+		) {
+			archive_handle->dpkg__action_data_subarchive = get_header_tar_lz;
+			return EXIT_SUCCESS;
+		}
 		if (ENABLE_FEATURE_SEAMLESS_LZMA
 		 && strcmp(name_ptr, "lzma") == 0
 		) {
diff -urdN busybox-1.20.2.orig/archival/libarchive/get_header_tar_lz.c busybox-1.20.2.new/archival/libarchive/get_header_tar_lz.c
--- busybox-1.20.2.orig/archival/libarchive/get_header_tar_lz.c	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.20.2.new/archival/libarchive/get_header_tar_lz.c	2012-12-07 18:12:58.000000000 +0100
@@ -0,0 +1,21 @@
+/* vi: set sw=4 ts=4: */
+/*
+ * Licensed under GPLv2 or later, see file LICENSE in this source tree.
+ */
+
+#include "libbb.h"
+#include "bb_archive.h"
+
+char FAST_FUNC get_header_tar_lz(archive_handle_t *archive_handle)
+{
+	/* Can't lseek over pipes */
+	archive_handle->seek = seek_by_read;
+
+	open_transformer_with_sig(archive_handle->src_fd, unpack_lz_stream, "lunzip");
+	archive_handle->offset = 0;
+	while (get_header_tar(archive_handle) == EXIT_SUCCESS)
+		continue;
+
+	/* Can only do one file at a time */
+	return EXIT_FAILURE;
+}
diff -urdN busybox-1.20.2.orig/archival/libarchive/lzip.h busybox-1.20.2.new/archival/libarchive/lzip.h
--- busybox-1.20.2.orig/archival/libarchive/lzip.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.20.2.new/archival/libarchive/lzip.h	2012-12-07 18:12:58.000000000 +0100
@@ -0,0 +1,259 @@
+/*  Lzip - Data compressor based on the LZMA algorithm
+    Copyright (C) 2008, 2009, 2010, 2011, 2012 Antonio Diaz Diaz.
+
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+typedef int State;
+
+enum { states = 12 };
+
+static inline bool St_is_char(const State st)
+{
+	return st < 7;
+}
+
+static inline State St_set_char(const State st)
+{
+	static const State next[states] = { 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 4, 5 };
+	return next[st];
+}
+
+static inline State St_set_match(const State st)
+{
+	return ((st < 7) ? 7 : 10);
+}
+
+static inline State St_set_rep(const State st)
+{
+	return ((st < 7) ? 8 : 11);
+}
+
+static inline State St_set_short_rep(const State st)
+{
+	return ((st < 7) ? 9 : 11);
+}
+
+
+enum {
+	min_dictionary_bits = 12,
+	min_dictionary_size = 1 << min_dictionary_bits,
+	max_dictionary_bits = 29,
+	max_dictionary_size = 1 << max_dictionary_bits,
+	literal_context_bits = 3,
+	pos_state_bits = 2,
+	pos_states = 1 << pos_state_bits,
+	pos_state_mask = pos_states - 1,
+
+	dis_slot_bits = 6,
+	start_dis_model = 4,
+	end_dis_model = 14,
+	modeled_distances = 1 << (end_dis_model / 2),
+	dis_align_bits = 4,
+	dis_align_size = 1 << dis_align_bits,
+
+	len_low_bits = 3,
+	len_mid_bits = 3,
+	len_high_bits = 8,
+	len_low_symbols = 1 << len_low_bits,
+	len_mid_symbols = 1 << len_mid_bits,
+	len_high_symbols = 1 << len_high_bits,
+	max_len_symbols = len_low_symbols + len_mid_symbols + len_high_symbols,
+
+	min_match_len = 2,					/* must be 2 */
+	max_match_len = min_match_len + max_len_symbols - 1,	/* 273 */
+	min_match_len_limit = 5,
+
+	max_dis_states = 4,
+
+	lz_num_models =
+		((1 << literal_context_bits) * 0x300) +
+		(2 * states * pos_states) +
+		(4 * states) +
+		(max_dis_states * (1 << dis_slot_bits)) +
+		(modeled_distances - end_dis_model + 1) +
+		dis_align_size,
+
+	len_num_models =
+		(pos_states * len_low_symbols) +
+		(pos_states * len_mid_symbols) +
+		len_high_symbols
+};
+
+static inline int get_dis_state(const int len)
+{
+	return MIN(len - min_match_len, max_dis_states - 1);
+}
+
+static inline int get_lit_state(const uint8_t prev_byte)
+{
+	return (prev_byte >> (8 - literal_context_bits));
+}
+
+
+enum { bit_model_move_bits = 5,
+	bit_model_total_bits = 11,
+	bit_model_total = 1 << bit_model_total_bits
+};
+
+typedef int Bit_model;
+
+static inline void Bm_init(Bit_model * const probability)
+{
+	*probability = bit_model_total / 2;
+}
+
+static inline void Bm_array_init(Bit_model * const p, const int size)
+{
+	int i = 0;
+
+	while (i < size)
+		p[i++] = bit_model_total / 2;
+}
+
+
+static inline int real_bits(const unsigned value)
+{
+	int bits = 0, i = 1;
+	unsigned mask = 1;
+
+	for (; mask > 0; ++i, mask <<= 1)
+		if (value & mask)
+			bits = i;
+	return bits;
+}
+
+
+static const uint8_t magic_string[4] = { 0x4C, 0x5A, 0x49, 0x50 };	/* "LZIP" */
+
+typedef uint8_t File_header[6];		/* 0-3 magic bytes */
+					/*   4 version */
+					/*   5 coded_dict_size */
+enum { Fh_size = 6 };
+
+static inline void Fh_set_magic(File_header data)
+{
+	memcpy(data, magic_string, 4);
+	data[4] = 1;
+}
+
+static inline bool Fh_verify_magic(const File_header data)
+{
+	return (memcmp(data, magic_string, 4) == 0 && data[4] == 1);
+}
+
+static inline int Fh_get_dictionary_size(const File_header data)
+{
+	int sz = (1 << (data[5] & 0x1F));
+
+	if (sz > min_dictionary_size && sz <= max_dictionary_size)
+		sz -= (sz / 16) * ((data[5] >> 5) & 0x07);
+	return sz;
+}
+
+static inline bool Fh_set_dictionary_size(File_header data, const int sz)
+{
+	if (sz >= min_dictionary_size && sz <= max_dictionary_size) {
+		data[5] = real_bits(sz - 1);
+		if (sz > min_dictionary_size) {
+			const int base_size = 1 << data[5];
+
+			const int wedge = base_size / 16;
+
+			int i;
+
+			for (i = 7; i >= 1; --i)
+				if (base_size - (i * wedge) >= sz) {
+					data[5] |= (i << 5);
+					break;
+				}
+		}
+		return true;
+	}
+	return false;
+}
+
+
+typedef uint8_t File_trailer[20];
+			/*  0-3  CRC32 of the uncompressed data */
+			/*  4-11 size of the uncompressed data */
+			/* 12-19 member size including header and trailer */
+
+enum { Ft_size = 20 };
+
+static inline uint32_t Ft_get_data_crc(const File_trailer data)
+{
+	uint32_t tmp = 0;
+	int i;
+
+	for (i = 3; i >= 0; --i) {
+		tmp <<= 8;
+		tmp += data[i];
+	}
+	return tmp;
+}
+
+static inline void Ft_set_data_crc(File_trailer data, uint32_t crc)
+{
+	int i;
+
+	for (i = 0; i <= 3; ++i) {
+		data[i] = (uint8_t) crc;
+		crc >>= 8;
+	}
+}
+
+static inline long long Ft_get_data_size(const File_trailer data)
+{
+	long long tmp = 0;
+	int i;
+
+	for (i = 11; i >= 4; --i) {
+		tmp <<= 8;
+		tmp += data[i];
+	}
+	return tmp;
+}
+
+static inline void Ft_set_data_size(File_trailer data, long long sz)
+{
+	int i;
+
+	for (i = 4; i <= 11; ++i) {
+		data[i] = (uint8_t) sz;
+		sz >>= 8;
+	}
+}
+
+static inline long long Ft_get_member_size(const File_trailer data)
+{
+	long long tmp = 0;
+	int i;
+
+	for (i = 19; i >= 12; --i) {
+		tmp <<= 8;
+		tmp += data[i];
+	}
+	return tmp;
+}
+
+static inline void Ft_set_member_size(File_trailer data, long long sz)
+{
+	int i;
+
+	for (i = 12; i <= 19; ++i) {
+		data[i] = (uint8_t) sz;
+		sz >>= 8;
+	}
+}
diff -urdN busybox-1.20.2.orig/archival/libarchive/open_transformer.c busybox-1.20.2.new/archival/libarchive/open_transformer.c
--- busybox-1.20.2.orig/archival/libarchive/open_transformer.c	2012-06-26 15:35:45.000000000 +0200
+++ busybox-1.20.2.new/archival/libarchive/open_transformer.c	2012-12-07 18:12:58.000000000 +0100
@@ -140,6 +140,17 @@
 		USE_FOR_NOMMU(xformer_prog = "bunzip2";)
 		goto found_magic;
 	}
+	if (ENABLE_FEATURE_SEAMLESS_LZ
+	 && magic.b16[0] == LZIP_MAGIC1
+	) {
+		offset = -4;
+		xread(fd, magic.b16, sizeof(magic.b16[0]));
+		if (magic.b16[0] == LZIP_MAGIC2) {
+			USE_FOR_MMU(xformer = unpack_lz_stream;)
+			USE_FOR_NOMMU(xformer_prog = "lunzip";)
+			goto found_magic;
+		}
+	}
 	if (ENABLE_FEATURE_SEAMLESS_XZ
 	 && magic.b16[0] == XZ_MAGIC1
 	) {
@@ -156,6 +167,7 @@
 	if (fail_if_not_detected)
 		bb_error_msg_and_die("no gzip"
 			IF_FEATURE_SEAMLESS_BZ2("/bzip2")
+			IF_FEATURE_SEAMLESS_LZ("/lzip")
 			IF_FEATURE_SEAMLESS_XZ("/xz")
 			" magic");
 	xlseek(fd, offset, SEEK_CUR);
@@ -192,6 +204,7 @@
 		else
 		if ((ENABLE_FEATURE_SEAMLESS_GZ && strcmp(sfx, "gz") == 0)
 		 || (ENABLE_FEATURE_SEAMLESS_BZ2 && strcmp(sfx, "bz2") == 0)
+		 || (ENABLE_FEATURE_SEAMLESS_LZ && strcmp(sfx, "lz") == 0)
 		 || (ENABLE_FEATURE_SEAMLESS_XZ && strcmp(sfx, "xz") == 0)
 		) {
 			setup_unzip_on_fd(fd, /*fail_if_not_detected:*/ 1);
diff -urdN busybox-1.20.2.orig/archival/lzip.c busybox-1.20.2.new/archival/lzip.c
--- busybox-1.20.2.orig/archival/lzip.c	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.20.2.new/archival/lzip.c	2012-12-07 18:12:58.000000000 +0100
@@ -0,0 +1,1537 @@
+/*
+ * lzip implementation for busybox
+ *
+ * Copyright (C) 2012 Antonio Diaz Diaz <ant_diaz@teleline.es>
+ *
+ * Licensed under GPLv2 or later, see file LICENSE in this source tree.
+ */
+
+//usage:#define lzip_trivial_usage
+//usage:       "[-123456789c"
+//usage:	IF_LUNZIP("d") "f"
+//usage:	IF_LUNZIP("t")
+//usage:       "] [-m MATCH_LENGTH] [-s DICT_SIZE] [FILE]..."
+//usage:#define lzip_full_usage "\n\n"
+//usage:       "Compress FILEs (or stdin) with lzip algorithm\n"
+//usage:     "\n	-1..9	Compression level"
+//usage:     "\n	-c	Write to stdout"
+//usage:	IF_LUNZIP("\n	-d	Decompress")
+//usage:     "\n	-f	Force"
+//usage:     "\n	-m	Match length limit [36]"
+//usage:     "\n	-s	Dictionary size limit [8MiB]"
+//usage:	IF_LUNZIP("\n	-t	Test compressed file integrity")
+
+
+#include "libbb.h"
+#include "bb_archive.h"
+#include "libarchive/lzip.h"
+
+
+#if CHAR_BIT != 8
+#error "Environments where CHAR_BIT != 8 are not supported."
+#endif
+
+
+static void CRC32_update_byte(uint32_t * crc, const uint8_t byte)
+{
+	*crc = global_crc32_table[(*crc ^ byte) & 0xFF] ^ (*crc >> 8);
+}
+
+
+enum { max_num_trials = 1 << 12,
+	price_shift = 6
+};
+
+
+static uint8_t * dis_slots;
+
+static void Dis_slots_init(void)
+{
+	int i, size, slot;
+
+	dis_slots = xmalloc((1 << 12) * sizeof dis_slots[0]);
+
+	for (slot = 0; slot < 4; ++slot)
+		dis_slots[slot] = slot;
+	for (i = 4, size = 2, slot = 4; slot < 24; slot += 2) {
+		memset(&dis_slots[i], slot, size);
+		memset(&dis_slots[i + size], slot + 1, size);
+		size <<= 1;
+		i += size;
+	}
+}
+
+static int get_slot(const uint32_t dis)
+{
+	if (dis < (1 << 12))
+		return dis_slots[dis];
+	if (dis < (1 << 23))
+		return dis_slots[dis >> 11] + 22;
+	return dis_slots[dis >> 22] + 44;
+}
+
+
+static int * prob_prices;
+
+static void Prob_prices_init(void)
+{
+	const int num_bits = (bit_model_total_bits - 2);
+	int i, j = 1, end = 2;
+
+	prob_prices = xmalloc((bit_model_total >> 2) * sizeof prob_prices[0]);
+
+	prob_prices[0] = bit_model_total_bits << price_shift;
+	for (i = num_bits - 1; i >= 0; --i, end <<= 1) {
+		for (; j < end; ++j)
+			prob_prices[j] = (i << price_shift) +
+				(((end - j) << price_shift) >> (num_bits - i - 1));
+	}
+}
+
+static int get_price(const int probability)
+{
+	return prob_prices[probability >> 2];
+}
+
+
+static int price0(const Bit_model probability)
+{
+	return get_price(probability);
+}
+
+static int price1(const Bit_model probability)
+{
+	return get_price(bit_model_total - probability);
+}
+
+static int price_bit(const Bit_model bm, const int bit)
+{
+	if (bit)
+		return price1(bm);
+	else
+		return price0(bm);
+}
+
+
+static int price_symbol(const Bit_model bm[], int symbol,
+						const int num_bits)
+{
+	int price = 0;
+
+	symbol |= (1 << num_bits);
+	while (symbol > 1) {
+		const int bit = symbol & 1;
+
+		symbol >>= 1;
+		price += price_bit(bm[symbol], bit);
+	}
+	return price;
+}
+
+
+static int price_symbol_reversed(const Bit_model bm[], int symbol,
+							const int num_bits)
+{
+	int price = 0;
+	int model = 1;
+	int i;
+
+	for (i = num_bits; i > 0; --i) {
+		const int bit = symbol & 1;
+
+		symbol >>= 1;
+		price += price_bit(bm[model], bit);
+		model = (model << 1) | bit;
+	}
+	return price;
+}
+
+
+static int price_matched(const Bit_model bm[], const int symbol,
+						const int match_byte)
+{
+	int price = 0;
+	int model = 1;
+	int i;
+
+	for (i = 7; i >= 0; --i) {
+		const int match_bit = (match_byte >> i) & 1;
+		int bit = (symbol >> i) & 1;
+
+		price += price_bit(bm[(match_bit << 8) + model + 0x100], bit);
+		model = (model << 1) | bit;
+		if (match_bit != bit) {
+			while (--i >= 0) {
+				bit = (symbol >> i) & 1;
+				price += price_bit(bm[model], bit);
+				model = (model << 1) | bit;
+			}
+			break;
+		}
+	}
+	return price;
+}
+
+
+enum {	/* bytes to keep in buffer before dictionary */
+	before_size = max_num_trials + 1,
+	/* bytes to keep in buffer after pos */
+	after_size = max_match_len,
+	num_prev_positions4 = 1 << 20,
+	num_prev_positions3 = 1 << 18,
+	num_prev_positions2 = 1 << 16,
+	num_prev_positions = num_prev_positions4 + num_prev_positions3 +
+		num_prev_positions2
+};
+
+struct Matchfinder {
+	long long partial_data_pos;
+	uint8_t *buffer;		/* input buffer */
+	int32_t *prev_positions;	/* last seen position of key */
+	int32_t *prev_pos_tree;
+	int dictionary_size;	/* bytes to keep in buffer before pos */
+	int buffer_size;
+	int pos;		/* current pos in buffer */
+	int cyclic_pos;		/* current pos in dictionary */
+	int stream_pos;		/* first byte not yet read from file */
+	int pos_limit;		/* when reached, a new block must be read */
+	int match_len_limit;
+	int cycles;
+	bool at_stream_end;	/* stream_pos shows real end of file */
+};
+
+static bool Mf_read_block(struct Matchfinder *const mf)
+{
+	if (!mf->at_stream_end && mf->stream_pos < mf->buffer_size) {
+		const int size = mf->buffer_size - mf->stream_pos;
+		const int rd =
+			full_read(STDIN_FILENO, mf->buffer + mf->stream_pos, size);
+		mf->stream_pos += rd;
+		if (rd < size) {
+			mf->at_stream_end = true;
+			mf->pos_limit = mf->buffer_size;
+		}
+	}
+	return mf->pos < mf->stream_pos;
+}
+
+
+static bool Mf_init(struct Matchfinder *const mf,
+			const int dict_size, const int match_len_limit)
+{
+	const int buffer_size_limit = (2 * dict_size) + before_size + after_size;
+	int i;
+
+	mf->partial_data_pos = 0;
+	mf->prev_positions =
+		(int32_t *) malloc(num_prev_positions * sizeof(int32_t));
+	if (!mf->prev_positions)
+		return false;
+	mf->pos = 0;
+	mf->cyclic_pos = 0;
+	mf->stream_pos = 0;
+	mf->match_len_limit = match_len_limit;
+	mf->cycles = (match_len_limit < max_match_len) ?
+		16 + (match_len_limit / 2) : 256;
+	mf->at_stream_end = false;
+
+	for (i = 0; i < num_prev_positions; ++i)
+		mf->prev_positions[i] = -1;
+	mf->buffer_size = MAX(65536, dict_size);
+	mf->buffer = (uint8_t *) malloc(mf->buffer_size);
+	if (!mf->buffer) {
+		free(mf->prev_positions);
+		return false;
+	}
+	if (Mf_read_block(mf) && !mf->at_stream_end &&
+		mf->buffer_size < buffer_size_limit) {
+		uint8_t *tmp;
+
+		mf->buffer_size = buffer_size_limit;
+		tmp = (uint8_t *) realloc(mf->buffer, mf->buffer_size);
+		if (!tmp) {
+			free(mf->buffer);
+			free(mf->prev_positions);
+			return false;
+		}
+		mf->buffer = tmp;
+		Mf_read_block(mf);
+	}
+	if (mf->at_stream_end && mf->stream_pos < dict_size)
+		mf->dictionary_size = MAX(min_dictionary_size, mf->stream_pos);
+	else
+		mf->dictionary_size = dict_size;
+	mf->pos_limit = mf->buffer_size;
+	if (!mf->at_stream_end)
+		mf->pos_limit -= after_size;
+	mf->prev_pos_tree =
+		(int32_t *) malloc(2 * mf->dictionary_size * sizeof(int32_t));
+	if (!mf->prev_pos_tree) {
+		free(mf->buffer);
+		free(mf->prev_positions);
+		return false;
+	}
+	return true;
+}
+
+
+static void Mf_free(struct Matchfinder *const mf)
+{
+	free(mf->prev_pos_tree);
+	free(mf->buffer);
+	free(mf->prev_positions);
+}
+
+static uint8_t Mf_peek(const struct Matchfinder *const mf, const int i)
+{
+	return mf->buffer[mf->pos + i];
+}
+
+static int Mf_available_bytes(const struct Matchfinder *const mf)
+{
+	return mf->stream_pos - mf->pos;
+}
+
+static long long Mf_data_position(const struct Matchfinder *const mf)
+{
+	return mf->partial_data_pos + mf->pos;
+}
+
+static bool Mf_finished(const struct Matchfinder *const mf)
+{
+	return mf->at_stream_end && mf->pos >= mf->stream_pos;
+}
+
+static const uint8_t *Mf_ptr_to_current_pos(const struct Matchfinder *const mf)
+{
+	return mf->buffer + mf->pos;
+}
+
+static int Mf_true_match_len(const struct Matchfinder *const mf,
+			const int index, const int distance, int len_limit)
+{
+	const uint8_t *const data = mf->buffer + mf->pos + index;
+	int i = 0;
+
+	if (index + len_limit > Mf_available_bytes(mf))
+		len_limit = Mf_available_bytes(mf) - index;
+	while (i < len_limit && data[i - distance] == data[i])
+		++i;
+	return i;
+}
+
+static void Mf_normalize_pos(struct Matchfinder *const mf)
+{
+	if (!mf->at_stream_end) {
+		int i;
+		const int offset = mf->pos - mf->dictionary_size - before_size;
+		const int size = mf->stream_pos - offset;
+
+		memmove(mf->buffer, mf->buffer + offset, size);
+		mf->partial_data_pos += offset;
+		mf->pos -= offset;
+		mf->stream_pos -= offset;
+		for (i = 0; i < num_prev_positions; ++i)
+			if (mf->prev_positions[i] >= 0)
+				mf->prev_positions[i] -= offset;
+		for (i = 0; i < 2 * mf->dictionary_size; ++i)
+			if (mf->prev_pos_tree[i] >= 0)
+				mf->prev_pos_tree[i] -= offset;
+		Mf_read_block(mf);
+	}
+}
+
+static void Mf_move_pos(struct Matchfinder *const mf)
+{
+	if (++mf->cyclic_pos >= mf->dictionary_size)
+		mf->cyclic_pos = 0;
+	if (++mf->pos >= mf->pos_limit)
+		Mf_normalize_pos(mf);
+}
+
+
+static int Mf_longest_match_len(struct Matchfinder *const mf,
+				int *const distances)
+{
+	int32_t *ptr0 = mf->prev_pos_tree + (mf->cyclic_pos << 1);
+	int32_t *ptr1 = ptr0 + 1;
+	int32_t *newptr;
+	const uint8_t *newdata;
+	int len = 0, len0 = 0, len1 = 0;
+	int maxlen = min_match_len - 1;
+	const int min_pos = (mf->pos >= mf->dictionary_size) ?
+		(mf->pos - mf->dictionary_size + 1) : 0;
+	const uint8_t *const data = mf->buffer + mf->pos;
+	int count, delta, key2, key3, key4, newpos, tmp;
+	int len_limit = mf->match_len_limit;
+
+	if (len_limit > Mf_available_bytes(mf)) {
+		len_limit = Mf_available_bytes(mf);
+		if (len_limit < 4)
+			return 0;
+	}
+
+	key2 = num_prev_positions4 + num_prev_positions3 +
+		(((int) data[0] << 8) | data[1]);
+	tmp = global_crc32_table[data[0]] ^ data[1] ^ ((uint32_t) data[2] << 8);
+	key3 = num_prev_positions4 + (int) (tmp & (num_prev_positions3 - 1));
+	key4 = (int) ((tmp ^ (global_crc32_table[data[3]] << 5)) &
+				(num_prev_positions4 - 1));
+
+	if (distances) {
+		int np = mf->prev_positions[key2];
+
+		if (np >= min_pos) {
+			distances[2] = mf->pos - np - 1;
+			maxlen = 2;
+		} else
+			distances[2] = 0x7FFFFFFF;
+		np = mf->prev_positions[key3];
+		if (np >= min_pos && mf->buffer[np] == data[0]) {
+			distances[3] = mf->pos - np - 1;
+			maxlen = 3;
+		} else
+			distances[3] = 0x7FFFFFFF;
+		distances[4] = 0x7FFFFFFF;
+	}
+
+	mf->prev_positions[key2] = mf->pos;
+	mf->prev_positions[key3] = mf->pos;
+	newpos = mf->prev_positions[key4];
+	mf->prev_positions[key4] = mf->pos;
+
+	for (count = mf->cycles;;) {
+		if (newpos < min_pos || --count < 0) {
+			*ptr0 = *ptr1 = -1;
+			break;
+		}
+		newdata = mf->buffer + newpos;
+		while (len < len_limit && newdata[len] == data[len])
+			++len;
+
+		delta = mf->pos - newpos;
+		if (distances)
+			while (maxlen < len)
+				distances[++maxlen] = delta - 1;
+
+		newptr = mf->prev_pos_tree +
+			((mf->cyclic_pos - delta +
+			((mf->cyclic_pos >= delta) ? 0 : mf->dictionary_size)) << 1);
+
+		if (len < len_limit) {
+			if (newdata[len] < data[len]) {
+				*ptr0 = newpos;
+				ptr0 = newptr + 1;
+				newpos = *ptr0;
+				len0 = len;
+				if (len1 < len)
+					len = len1;
+			} else {
+				*ptr1 = newpos;
+				ptr1 = newptr;
+				newpos = *ptr1;
+				len1 = len;
+				if (len0 < len)
+					len = len0;
+			}
+		} else {
+			*ptr0 = newptr[0];
+			*ptr1 = newptr[1];
+			break;
+		}
+	}
+	if (distances) {
+		if (distances[3] > distances[4])
+			distances[3] = distances[4];
+		if (distances[2] > distances[3])
+			distances[2] = distances[3];
+	}
+	return maxlen;
+}
+
+
+enum { re_buffer_size = 16384 };
+
+struct Range_encoder {
+	uint64_t low;
+	long long partial_member_pos;
+	uint8_t *buffer;		/* output buffer */
+	int pos;			/* current pos in buffer */
+	uint32_t range;
+	int ff_count;
+	uint8_t cache;
+};
+
+static bool Re_init(struct Range_encoder *const renc)
+{
+	renc->low = 0;
+	renc->partial_member_pos = 0;
+	renc->buffer = (uint8_t *) malloc(re_buffer_size);
+	if (!renc->buffer)
+		return false;
+	renc->pos = 0;
+	renc->range = 0xFFFFFFFFU;
+	renc->ff_count = 0;
+	renc->cache = 0;
+	return true;
+}
+
+static void Re_free(struct Range_encoder *const renc)
+{
+	free(renc->buffer);
+}
+
+static bool Re_flush_data(struct Range_encoder *const renc)
+{
+	if (renc->pos > 0) {
+		if (full_write(STDOUT_FILENO, renc->buffer, renc->pos) != renc->pos)
+			return false;
+		renc->partial_member_pos += renc->pos;
+		renc->pos = 0;
+	}
+	return true;
+}
+
+static void Re_put_byte(struct Range_encoder *const renc, const uint8_t b)
+{
+	renc->buffer[renc->pos] = b;
+	if (++renc->pos >= re_buffer_size)
+		Re_flush_data(renc);
+}
+
+static void Re_shift_low(struct Range_encoder *const renc)
+{
+	const bool carry = (renc->low > 0xFFFFFFFFU);
+
+	if (carry || renc->low < 0xFF000000U) {
+		Re_put_byte(renc, renc->cache + carry);
+		for (; renc->ff_count > 0; --renc->ff_count)
+			Re_put_byte(renc, 0xFF + carry);
+		renc->cache = renc->low >> 24;
+	} else
+		++renc->ff_count;
+	renc->low = (renc->low & 0x00FFFFFFU) << 8;
+}
+
+static long long Re_member_position(const struct Range_encoder *const renc)
+{
+	return renc->partial_member_pos + renc->pos + renc->ff_count;
+}
+
+static void Re_flush(struct Range_encoder *const renc)
+{
+	int i;
+
+	for (i = 0; i < 5; ++i)
+		Re_shift_low(renc);
+}
+
+static void Re_encode(struct Range_encoder *const renc,
+				const int symbol, const int num_bits)
+{
+	int i;
+
+	for (i = num_bits - 1; i >= 0; --i) {
+		renc->range >>= 1;
+		if ((symbol >> i) & 1)
+			renc->low += renc->range;
+		if (renc->range <= 0x00FFFFFFU) {
+			renc->range <<= 8;
+			Re_shift_low(renc);
+		}
+	}
+}
+
+static void Re_encode_bit(struct Range_encoder *const renc,
+				Bit_model * const probability, const int bit)
+{
+	const uint32_t bound =
+		(renc->range >> bit_model_total_bits) * *probability;
+	if (!bit) {
+		renc->range = bound;
+		*probability +=
+			(bit_model_total - *probability) >> bit_model_move_bits;
+	} else {
+		renc->low += bound;
+		renc->range -= bound;
+		*probability -= *probability >> bit_model_move_bits;
+	}
+	if (renc->range <= 0x00FFFFFFU) {
+		renc->range <<= 8;
+		Re_shift_low(renc);
+	}
+}
+
+static void Re_encode_tree(struct Range_encoder *const renc,
+				Bit_model bm[], const int symbol,
+				const int num_bits)
+{
+	int mask = (1 << (num_bits - 1));
+	int model = 1;
+	int i;
+
+	for (i = num_bits; i > 0; --i, mask >>= 1) {
+		const int bit = (symbol & mask);
+
+		Re_encode_bit(renc, &bm[model], bit);
+		model <<= 1;
+		if (bit)
+			model |= 1;
+	}
+}
+
+static void Re_encode_tree_reversed(struct Range_encoder *const renc,
+			Bit_model bm[], int symbol, const int num_bits)
+{
+	int model = 1;
+	int i;
+
+	for (i = num_bits; i > 0; --i) {
+		const int bit = symbol & 1;
+
+		Re_encode_bit(renc, &bm[model], bit);
+		model = (model << 1) | bit;
+		symbol >>= 1;
+	}
+}
+
+static void Re_encode_matched(struct Range_encoder *const renc,
+				Bit_model bm[], int symbol, int match_byte)
+{
+	int model = 1;
+	int i;
+
+	for (i = 7; i >= 0; --i) {
+		const int match_bit = (match_byte >> i) & 1;
+		int bit = (symbol >> i) & 1;
+
+		Re_encode_bit(renc, &bm[(match_bit << 8) + model + 0x100], bit);
+		model = (model << 1) | bit;
+		if (match_bit != bit) {
+			while (--i >= 0) {
+				bit = (symbol >> i) & 1;
+				Re_encode_bit(renc, &bm[model], bit);
+				model = (model << 1) | bit;
+			}
+			break;
+		}
+	}
+}
+
+
+struct Len_encoder {
+	Bit_model choice1;
+	Bit_model choice2;
+	Bit_model bm_low[pos_states][len_low_symbols];
+	Bit_model bm_mid[pos_states][len_mid_symbols];
+	Bit_model bm_high[len_high_symbols];
+	int prices[pos_states][max_len_symbols];
+	int len_symbols;
+	int counters[pos_states];
+};
+
+static void Lee_update_prices(struct Len_encoder *const len_encoder,
+					const int pos_state)
+{
+	int *const pps = len_encoder->prices[pos_state];
+	int tmp = price0(len_encoder->choice1);
+	int len = 0;
+
+	for (; len < len_low_symbols && len < len_encoder->len_symbols; ++len)
+		pps[len] = tmp +
+			price_symbol(len_encoder->bm_low[pos_state], len, len_low_bits);
+	tmp = price1(len_encoder->choice1);
+	for (;
+		len < len_low_symbols + len_mid_symbols
+		&& len < len_encoder->len_symbols; ++len)
+		pps[len] =
+			tmp + price0(len_encoder->choice2) +
+			price_symbol(len_encoder->bm_mid[pos_state],
+						len - len_low_symbols, len_mid_bits);
+	for (; len < len_encoder->len_symbols; ++len)
+		/* using 4 slots per value makes "Lee_price" faster */
+		len_encoder->prices[3][len] = len_encoder->prices[2][len] =
+			len_encoder->prices[1][len] = len_encoder->prices[0][len] =
+			tmp + price1(len_encoder->choice2) +
+			price_symbol(len_encoder->bm_high,
+				len - len_low_symbols - len_mid_symbols,
+				len_high_bits);
+	len_encoder->counters[pos_state] = len_encoder->len_symbols;
+}
+
+static void Lee_init(struct Len_encoder *const len_encoder,
+				const int len_limit)
+{
+	int i;
+
+	Bm_init(&len_encoder->choice1);
+	Bm_init(&len_encoder->choice2);
+	Bm_array_init(&len_encoder->bm_low[0][0], len_num_models);
+	len_encoder->len_symbols = len_limit + 1 - min_match_len;
+	for (i = 0; i < pos_states; ++i)
+		Lee_update_prices(len_encoder, i);
+}
+
+static void Lee_encode(struct Len_encoder *const len_encoder,
+			struct Range_encoder *const renc,
+			int symbol, const int pos_state)
+{
+	symbol -= min_match_len;
+	if (symbol < len_low_symbols) {
+		Re_encode_bit(renc, &len_encoder->choice1, 0);
+		Re_encode_tree(renc, len_encoder->bm_low[pos_state], symbol,
+					len_low_bits);
+	} else {
+		Re_encode_bit(renc, &len_encoder->choice1, 1);
+		if (symbol < len_low_symbols + len_mid_symbols) {
+			Re_encode_bit(renc, &len_encoder->choice2, 0);
+			Re_encode_tree(renc, len_encoder->bm_mid[pos_state],
+						symbol - len_low_symbols, len_mid_bits);
+		} else {
+			Re_encode_bit(renc, &len_encoder->choice2, 1);
+			Re_encode_tree(renc, len_encoder->bm_high,
+						symbol - len_low_symbols - len_mid_symbols,
+						len_high_bits);
+		}
+	}
+	if (--len_encoder->counters[pos_state] <= 0)
+		Lee_update_prices(len_encoder, pos_state);
+}
+
+static int Lee_price(const struct Len_encoder *const len_encoder,
+				const int symbol, const int pos_state)
+{
+	return len_encoder->prices[pos_state][symbol - min_match_len];
+}
+
+
+enum { infinite_price = 0x0FFFFFFF,
+	num_rep_distances = 4			/* must be 4 */
+};
+
+struct Trial {
+	State state;
+	int dis;
+	int prev_index;		/* index of prev trial in trials[] */
+	int price;		/* dual use var; cumulative price, match length */
+	int reps[num_rep_distances];
+};
+
+static void Tr_update(struct Trial *const trial,
+				const int d, const int p_i, const int pr)
+{
+	if (pr < trial->price) {
+		trial->dis = d;
+		trial->prev_index = p_i;
+		trial->price = pr;
+	}
+}
+
+
+struct LZ_encoder {
+	int longest_match_found;
+	uint32_t crc;
+
+	Bit_model bm_literal[1 << literal_context_bits][0x300];
+	Bit_model bm_match[states][pos_states];
+	Bit_model bm_rep[states];
+	Bit_model bm_rep0[states];
+	Bit_model bm_rep1[states];
+	Bit_model bm_rep2[states];
+	Bit_model bm_len[states][pos_states];
+	Bit_model bm_dis_slot[max_dis_states][1 << dis_slot_bits];
+	Bit_model bm_dis[modeled_distances - end_dis_model + 1];
+	Bit_model bm_align[dis_align_size];
+
+	struct Matchfinder *matchfinder;
+	struct Range_encoder range_encoder;
+	struct Len_encoder len_encoder;
+	struct Len_encoder rep_match_len_encoder;
+
+	int num_dis_slots;
+	int match_distances[max_match_len + 1];
+	struct Trial trials[max_num_trials];
+
+	int dis_slot_prices[max_dis_states][2 * max_dictionary_bits];
+	int dis_prices[max_dis_states][modeled_distances];
+	int align_prices[dis_align_size];
+	int align_price_count;
+};
+
+static void LZe_fill_align_prices(struct LZ_encoder *const encoder)
+{
+	int i;
+
+	for (i = 0; i < dis_align_size; ++i)
+		encoder->align_prices[i] =
+			price_symbol_reversed(encoder->bm_align, i, dis_align_bits);
+	encoder->align_price_count = dis_align_size;
+}
+
+static bool LZe_init(struct LZ_encoder *const encoder,
+			struct Matchfinder *const mf, const File_header header)
+{
+	int i;
+
+	encoder->longest_match_found = 0;
+	encoder->crc = 0xFFFFFFFFU;
+
+	Bm_array_init(&encoder->bm_literal[0][0], lz_num_models);
+
+	encoder->matchfinder = mf;
+	if (!Re_init(&encoder->range_encoder))
+		return false;
+	Lee_init(&encoder->len_encoder, encoder->matchfinder->match_len_limit);
+	Lee_init(&encoder->rep_match_len_encoder,
+			encoder->matchfinder->match_len_limit);
+	encoder->num_dis_slots =
+		2 * real_bits(encoder->matchfinder->dictionary_size - 1);
+
+	LZe_fill_align_prices(encoder);
+
+	for (i = 0; i < Fh_size; ++i)
+		Re_put_byte(&encoder->range_encoder, header[i]);
+	return true;
+}
+
+
+static void LZe_free(struct LZ_encoder *const encoder)
+{
+	Re_free(&encoder->range_encoder);
+}
+
+static uint32_t LZe_crc(const struct LZ_encoder *const encoder)
+{
+	return encoder->crc ^ 0xFFFFFFFFU;
+}
+
+
+	/* move-to-front dis in/into reps */
+static void LZe_mtf_reps(const int dis, int reps[num_rep_distances])
+{
+	int i;
+
+	if (dis >= num_rep_distances) {
+		for (i = num_rep_distances - 1; i > 0; --i)
+			reps[i] = reps[i - 1];
+		reps[0] = dis - num_rep_distances;
+	} else if (dis > 0) {
+		const int distance = reps[dis];
+
+		for (i = dis; i > 0; --i)
+			reps[i] = reps[i - 1];
+		reps[0] = distance;
+	}
+}
+
+static int LZe_price_rep_len1(const struct LZ_encoder *const encoder,
+					const State state, const int pos_state)
+{
+	return price0(encoder->bm_rep0[state]) +
+		price0(encoder->bm_len[state][pos_state]);
+}
+
+static int LZe_price_rep(const struct LZ_encoder *const encoder, const int rep,
+				const State state, const int pos_state)
+{
+	int price;
+
+	if (rep == 0)
+		return price0(encoder->bm_rep0[state]) +
+			price1(encoder->bm_len[state][pos_state]);
+	price = price1(encoder->bm_rep0[state]);
+	if (rep == 1)
+		price += price0(encoder->bm_rep1[state]);
+	else {
+		price += price1(encoder->bm_rep1[state]);
+		price += price_bit(encoder->bm_rep2[state], rep - 2);
+	}
+	return price;
+}
+
+static int LZe_price_dis(const struct LZ_encoder *const encoder,
+				const int dis, const int dis_state)
+{
+	if (dis < modeled_distances)
+		return encoder->dis_prices[dis_state][dis];
+	else
+		return encoder->dis_slot_prices[dis_state][get_slot(dis)] +
+			encoder->align_prices[dis & (dis_align_size - 1)];
+}
+
+static int LZe_price_pair(const struct LZ_encoder *const encoder,
+					const int dis, const int len,
+					const int pos_state)
+{
+	if (len <= min_match_len && dis >= modeled_distances)
+		return infinite_price;
+	return Lee_price(&encoder->len_encoder, len, pos_state) +
+		LZe_price_dis(encoder, dis, get_dis_state(len));
+}
+
+static int LZe_price_literal(const struct LZ_encoder *const encoder,
+					uint8_t prev_byte, uint8_t symbol)
+{
+	return price_symbol(encoder->bm_literal[get_lit_state(prev_byte)], symbol, 8);
+}
+
+static int LZe_price_matched(const struct LZ_encoder *const encoder,
+					uint8_t prev_byte, uint8_t symbol,
+					uint8_t match_byte)
+{
+	return price_matched(encoder->bm_literal[get_lit_state(prev_byte)],
+						symbol, match_byte);
+}
+
+static void LZe_encode_literal(struct LZ_encoder *const encoder,
+					uint8_t prev_byte, uint8_t symbol)
+{
+	Re_encode_tree(&encoder->range_encoder,
+		encoder->bm_literal[get_lit_state(prev_byte)], symbol, 8);
+}
+
+static void LZe_encode_matched(struct LZ_encoder *const encoder,
+					uint8_t prev_byte, uint8_t symbol,
+					uint8_t match_byte)
+{
+	Re_encode_matched(&encoder->range_encoder,
+			encoder->bm_literal[get_lit_state(prev_byte)],
+			symbol, match_byte);
+}
+
+static void LZe_encode_pair(struct LZ_encoder *const encoder,
+				const uint32_t dis, const int len,
+				const int pos_state)
+{
+	const int dis_slot = get_slot(dis);
+
+	Lee_encode(&encoder->len_encoder, &encoder->range_encoder, len,
+			pos_state);
+	Re_encode_tree(&encoder->range_encoder,
+			encoder->bm_dis_slot[get_dis_state(len)], dis_slot,
+			dis_slot_bits);
+
+	if (dis_slot >= start_dis_model) {
+		const int direct_bits = (dis_slot >> 1) - 1;
+		const uint32_t base = (2 | (dis_slot & 1)) << direct_bits;
+		const uint32_t direct_dis = dis - base;
+
+		if (dis_slot < end_dis_model)
+			Re_encode_tree_reversed(&encoder->range_encoder,
+					encoder->bm_dis + base - dis_slot,
+					direct_dis, direct_bits);
+		else {
+			Re_encode(&encoder->range_encoder, direct_dis >> dis_align_bits,
+					direct_bits - dis_align_bits);
+			Re_encode_tree_reversed(&encoder->range_encoder,
+					encoder->bm_align, direct_dis,
+					dis_align_bits);
+			if (--encoder->align_price_count <= 0)
+				LZe_fill_align_prices(encoder);
+		}
+	}
+}
+
+static int LZe_read_match_distances(struct LZ_encoder *const encoder)
+{
+	int len = Mf_longest_match_len(encoder->matchfinder,
+						encoder->match_distances);
+
+	if (len == encoder->matchfinder->match_len_limit && len < max_match_len)
+		len += Mf_true_match_len(encoder->matchfinder, len,
+					encoder->match_distances[len] + 1,
+					max_match_len - len);
+	return len;
+}
+
+static void LZe_move_pos(struct LZ_encoder *const encoder, int n)
+{
+	if (--n >= 0)
+		Mf_move_pos(encoder->matchfinder);
+	while (--n >= 0) {
+		Mf_longest_match_len(encoder->matchfinder, 0);
+		Mf_move_pos(encoder->matchfinder);
+	}
+}
+
+static void LZe_backward(struct LZ_encoder *const encoder, int cur)
+{
+	int *const dis = &encoder->trials[cur].dis;
+
+	while (cur > 0) {
+		const int prev_index = encoder->trials[cur].prev_index;
+		struct Trial *const prev_trial = &encoder->trials[prev_index];
+
+		prev_trial->price = cur - prev_index;	/* len */
+		cur = *dis;
+		*dis = prev_trial->dis;
+		prev_trial->dis = cur;
+		cur = prev_index;
+	}
+}
+
+	/* End Of Stream mark => (dis == 0xFFFFFFFFU, len == min_match_len) */
+static bool LZe_full_flush(struct LZ_encoder *const encoder, const State state)
+{
+	int i;
+	const int pos_state =
+		Mf_data_position(encoder->matchfinder) & pos_state_mask;
+	File_trailer trailer;
+
+	Re_encode_bit(&encoder->range_encoder,
+				&encoder->bm_match[state][pos_state], 1);
+	Re_encode_bit(&encoder->range_encoder, &encoder->bm_rep[state], 0);
+	LZe_encode_pair(encoder, 0xFFFFFFFFU, min_match_len, pos_state);
+	Re_flush(&encoder->range_encoder);
+	Ft_set_data_crc(trailer, LZe_crc(encoder));
+	Ft_set_data_size(trailer, Mf_data_position(encoder->matchfinder));
+	Ft_set_member_size(trailer, Re_member_position(&encoder->range_encoder) +
+					Ft_size);
+	for (i = 0; i < Ft_size; ++i)
+		Re_put_byte(&encoder->range_encoder, trailer[i]);
+	return Re_flush_data(&encoder->range_encoder);
+}
+
+
+static void LZe_fill_distance_prices(struct LZ_encoder *const encoder)
+{
+	int dis, dis_state;
+
+	for (dis = start_dis_model; dis < modeled_distances; ++dis) {
+		const int dis_slot = dis_slots[dis];
+		const int direct_bits = (dis_slot >> 1) - 1;
+		const int base = (2 | (dis_slot & 1)) << direct_bits;
+		const int price =
+			price_symbol_reversed(encoder->bm_dis + base - dis_slot,
+						dis - base, direct_bits);
+
+		for (dis_state = 0; dis_state < max_dis_states; ++dis_state)
+			encoder->dis_prices[dis_state][dis] = price;
+	}
+
+	for (dis_state = 0; dis_state < max_dis_states; ++dis_state) {
+		int *const dsp = encoder->dis_slot_prices[dis_state];
+		int *const dp = encoder->dis_prices[dis_state];
+		const Bit_model *const bmds = encoder->bm_dis_slot[dis_state];
+		int slot = 0;
+
+		for (; slot < end_dis_model && slot < encoder->num_dis_slots; ++slot)
+			dsp[slot] = price_symbol(bmds, slot, dis_slot_bits);
+		for (; slot < encoder->num_dis_slots; ++slot)
+			dsp[slot] = price_symbol(bmds, slot, dis_slot_bits) +
+				((((slot >> 1) - 1) - dis_align_bits) << price_shift);
+
+		for (dis = 0; dis < start_dis_model; ++dis)
+			dp[dis] = dsp[dis];
+		for (; dis < modeled_distances; ++dis)
+			dp[dis] += dsp[dis_slots[dis]];
+	}
+}
+
+
+/* Return value == number of bytes advanced (ahead).
+   trials[0]..trials[retval-1] contain the steps to encode.
+   ( trials[0].dis == -1 && trials[0].price == 1 ) means literal.
+*/
+static int LZe_sequence_optimizer(struct LZ_encoder *const encoder,
+				const int reps[num_rep_distances],
+				const State state)
+{
+	int main_len, i, rep, cur = 0, num_trials;
+	int replens[num_rep_distances];
+	int rep_index = 0;
+
+	if (encoder->longest_match_found > 0) {	/* from previous call */
+		main_len = encoder->longest_match_found;
+		encoder->longest_match_found = 0;
+	} else
+		main_len = LZe_read_match_distances(encoder);
+
+	for (i = 0; i < num_rep_distances; ++i) {
+		replens[i] =
+			Mf_true_match_len(encoder->matchfinder, 0, reps[i] + 1,
+							max_match_len);
+		if (replens[i] > replens[rep_index])
+			rep_index = i;
+	}
+	if (replens[rep_index] >= encoder->matchfinder->match_len_limit) {
+		encoder->trials[0].dis = rep_index;
+		encoder->trials[0].price = replens[rep_index];
+		LZe_move_pos(encoder, replens[rep_index]);
+		return replens[rep_index];
+	}
+
+	if (main_len >= encoder->matchfinder->match_len_limit) {
+		encoder->trials[0].dis =
+			encoder->match_distances[encoder->matchfinder->match_len_limit] +
+			num_rep_distances;
+		encoder->trials[0].price = main_len;
+		LZe_move_pos(encoder, main_len);
+		return main_len;
+	}
+
+	{
+	const int pos_state =
+		Mf_data_position(encoder->matchfinder) & pos_state_mask;
+	const int match_price = price1(encoder->bm_match[state][pos_state]);
+	const int rep_match_price =
+		match_price + price1(encoder->bm_rep[state]);
+	const uint8_t prev_byte = Mf_peek(encoder->matchfinder, -1);
+	const uint8_t cur_byte = Mf_peek(encoder->matchfinder, 0);
+	const uint8_t match_byte =
+		Mf_peek(encoder->matchfinder, -reps[0] - 1);
+
+	encoder->trials[0].state = state;
+	for (i = 0; i < num_rep_distances; ++i)
+		encoder->trials[0].reps[i] = reps[i];
+	encoder->trials[1].dis = -1;
+	encoder->trials[1].prev_index = 0;
+	encoder->trials[1].price =
+		price0(encoder->bm_match[state][pos_state]);
+	if (St_is_char(state))
+		encoder->trials[1].price +=
+			LZe_price_literal(encoder, prev_byte, cur_byte);
+	else
+		encoder->trials[1].price +=
+			LZe_price_matched(encoder, prev_byte, cur_byte, match_byte);
+
+	if (match_byte == cur_byte)
+		Tr_update(&encoder->trials[1], 0, 0, rep_match_price +
+			LZe_price_rep_len1(encoder, state, pos_state));
+
+	if (main_len < min_match_len) {
+		encoder->trials[0].dis = encoder->trials[1].dis;
+		encoder->trials[0].price = 1;
+		Mf_move_pos(encoder->matchfinder);
+		return 1;
+	}
+
+	if (main_len <= replens[rep_index]) {
+		int len;
+
+		main_len = replens[rep_index];
+		for (len = min_match_len; len <= main_len; ++len)
+			encoder->trials[len].price = infinite_price;
+	} else {
+		int len;
+		const int normal_match_price =
+			match_price + price0(encoder->bm_rep[state]);
+
+		for (len = min_match_len; len <= main_len; ++len) {
+			encoder->trials[len].dis =
+				encoder->match_distances[len] + num_rep_distances;
+			encoder->trials[len].prev_index = 0;
+			encoder->trials[len].price = normal_match_price +
+				LZe_price_pair(encoder, encoder->match_distances[len],
+							len, pos_state);
+		}
+	}
+
+	for (rep = 0; rep < num_rep_distances; ++rep) {
+		const int price = rep_match_price +
+			LZe_price_rep(encoder, rep, state, pos_state);
+		int len;
+
+		for (len = min_match_len; len <= replens[rep]; ++len)
+			Tr_update(&encoder->trials[len], rep, 0, price +
+					Lee_price(&encoder->rep_match_len_encoder, len,
+								pos_state));
+	}
+	}
+
+	num_trials = main_len;
+	Mf_move_pos(encoder->matchfinder);
+
+	while (true) {
+		struct Trial *cur_trial, *next_trial;
+		int newlen, pos_state, prev_index, len_limit;
+		int next_price, match_price, rep_match_price;
+		uint8_t prev_byte, cur_byte, match_byte;
+
+		if (++cur >= num_trials) {	/* no more initialized trials */
+			LZe_backward(encoder, cur);
+			return cur;
+		}
+		newlen = LZe_read_match_distances(encoder);
+		if (newlen >= encoder->matchfinder->match_len_limit) {
+			encoder->longest_match_found = newlen;
+			LZe_backward(encoder, cur);
+			return cur;
+		}
+
+		cur_trial = &encoder->trials[cur];
+		prev_index = cur_trial->prev_index;
+		cur_trial->state = encoder->trials[prev_index].state;
+
+		for (i = 0; i < num_rep_distances; ++i)
+			cur_trial->reps[i] = encoder->trials[prev_index].reps[i];
+
+		if (prev_index == cur - 1) {
+			if (cur_trial->dis == 0)
+				cur_trial->state = St_set_short_rep(cur_trial->state);
+			else
+				cur_trial->state = St_set_char(cur_trial->state);
+		} else {
+			if (cur_trial->dis < num_rep_distances)
+				cur_trial->state = St_set_rep(cur_trial->state);
+			else
+				cur_trial->state = St_set_match(cur_trial->state);
+			LZe_mtf_reps(cur_trial->dis, cur_trial->reps);
+		}
+
+		pos_state = Mf_data_position(encoder->matchfinder) & pos_state_mask;
+		prev_byte = Mf_peek(encoder->matchfinder, -1);
+		cur_byte = Mf_peek(encoder->matchfinder, 0);
+		match_byte = Mf_peek(encoder->matchfinder, -cur_trial->reps[0] - 1);
+
+		next_price = cur_trial->price +
+			price0(encoder->bm_match[cur_trial->state][pos_state]);
+		if (St_is_char(cur_trial->state))
+			next_price += LZe_price_literal(encoder, prev_byte, cur_byte);
+		else
+			next_price += LZe_price_matched(encoder,
+					prev_byte, cur_byte, match_byte);
+		Mf_move_pos(encoder->matchfinder);
+
+		next_trial = &encoder->trials[cur + 1];
+
+		Tr_update(next_trial, -1, cur, next_price);
+
+		match_price =
+			cur_trial->price +
+			price1(encoder->bm_match[cur_trial->state][pos_state]);
+		rep_match_price =
+			match_price + price1(encoder->bm_rep[cur_trial->state]);
+
+		if (match_byte == cur_byte && next_trial->dis != 0)
+			Tr_update(next_trial, 0, cur, rep_match_price +
+				LZe_price_rep_len1(encoder, cur_trial->state, pos_state));
+
+		len_limit = MIN(MIN(max_num_trials - 1 - cur,
+				Mf_available_bytes(encoder->matchfinder)),
+				encoder->matchfinder->match_len_limit);
+		if (len_limit < min_match_len)
+			continue;
+
+		for (rep = 0; rep < num_rep_distances; ++rep) {
+			const int dis = cur_trial->reps[rep] + 1;
+			int len = 0;
+			const uint8_t *const data =
+				Mf_ptr_to_current_pos(encoder->matchfinder) - 1;
+
+			while (len < len_limit && data[len] == data[len - dis])
+				++len;
+			if (len >= min_match_len) {
+				const int price = rep_match_price +
+					LZe_price_rep(encoder, rep, cur_trial->state, pos_state);
+				while (num_trials < cur + len)
+					encoder->trials[++num_trials].price = infinite_price;
+				for (; len >= min_match_len; --len)
+					Tr_update(&encoder->trials[cur + len], rep, cur, price +
+							Lee_price(&encoder->rep_match_len_encoder, len,
+										pos_state));
+			}
+		}
+
+		if (newlen <= len_limit &&
+			(newlen > min_match_len ||
+			(newlen == min_match_len &&
+			encoder->match_distances[min_match_len] < modeled_distances))) {
+			const int normal_match_price = match_price +
+				price0(encoder->bm_rep[cur_trial->state]);
+			int len;
+			int dis = encoder->match_distances[min_match_len];
+			int dis_state = get_dis_state(min_match_len);
+			int dis_price = infinite_price;
+
+			while (num_trials < cur + newlen)
+				encoder->trials[++num_trials].price = infinite_price;
+
+			if (dis < modeled_distances)
+				Tr_update(&encoder->trials[cur + min_match_len],
+						dis + num_rep_distances, cur,
+						normal_match_price +
+						encoder->dis_prices[dis_state][dis] +
+						Lee_price(&encoder->len_encoder, min_match_len,
+									pos_state));
+
+			for (len = min_match_len + 1; len <= newlen; ++len) {
+				if (dis != encoder->match_distances[len] ||
+					dis_state < max_dis_states - 1) {
+					dis = encoder->match_distances[len];
+					dis_state = get_dis_state(len);
+					dis_price = LZe_price_dis(encoder, dis, dis_state);
+				}
+				Tr_update(&encoder->trials[cur + len],
+						dis + num_rep_distances, cur,
+						normal_match_price + dis_price +
+						Lee_price(&encoder->len_encoder, len, pos_state));
+			}
+		}
+	}
+}
+
+
+static bool LZe_encode_member(struct LZ_encoder *const encoder)
+{
+	const int fill_count =
+		(encoder->matchfinder->match_len_limit > 12) ? 512 : 2048;
+	int fill_counter = 0;
+	int ahead, i;
+	int rep_distances[num_rep_distances];
+	State state = 0;
+
+	for (i = 0; i < num_rep_distances; ++i)
+		rep_distances[i] = 0;
+
+	if (!Mf_finished(encoder->matchfinder)) {	/* encode first byte */
+		const uint8_t prev_byte = 0;
+		const uint8_t cur_byte = Mf_peek(encoder->matchfinder, 0);
+
+		Re_encode_bit(&encoder->range_encoder, &encoder->bm_match[state][0], 0);
+		LZe_encode_literal(encoder, prev_byte, cur_byte);
+		CRC32_update_byte(&encoder->crc, cur_byte);
+		Mf_longest_match_len(encoder->matchfinder, 0);
+		Mf_move_pos(encoder->matchfinder);
+	}
+
+	while (!Mf_finished(encoder->matchfinder)) {
+		if (fill_counter <= 0) {
+			LZe_fill_distance_prices(encoder);
+			fill_counter = fill_count;
+		}
+
+		ahead = LZe_sequence_optimizer(encoder, rep_distances, state);
+		fill_counter -= ahead;
+
+		for (i = 0; ahead > 0;) {
+			const int pos_state =
+				(Mf_data_position(encoder->matchfinder) -
+				ahead) & pos_state_mask;
+			const int dis = encoder->trials[i].dis;
+			const int len = encoder->trials[i].price;
+			bool bit = (dis < 0 && len == 1);
+
+			Re_encode_bit(&encoder->range_encoder,
+						&encoder->bm_match[state][pos_state], !bit);
+			if (bit) {	/* literal byte */
+				const uint8_t prev_byte =
+					Mf_peek(encoder->matchfinder, -ahead - 1);
+				const uint8_t cur_byte =
+					Mf_peek(encoder->matchfinder, -ahead);
+				CRC32_update_byte(&encoder->crc, cur_byte);
+				if (St_is_char(state))
+					LZe_encode_literal(encoder, prev_byte, cur_byte);
+				else {
+					const uint8_t match_byte =
+						Mf_peek(encoder->matchfinder,
+							-ahead - rep_distances[0] - 1);
+					LZe_encode_matched(encoder, prev_byte,
+							cur_byte, match_byte);
+				}
+				state = St_set_char(state);
+			} else {	/* match or repeated match */
+
+				encoder->crc = crc32_block_endian0(encoder->crc,
+						Mf_ptr_to_current_pos(encoder->matchfinder) - ahead,
+							len, global_crc32_table);
+				LZe_mtf_reps(dis, rep_distances);
+				bit = (dis < num_rep_distances);
+				Re_encode_bit(&encoder->range_encoder,
+							&encoder->bm_rep[state], bit);
+				if (bit) {
+					bit = (dis == 0);
+					Re_encode_bit(&encoder->range_encoder,
+								&encoder->bm_rep0[state], !bit);
+					if (bit)
+						Re_encode_bit(&encoder->range_encoder,
+								&encoder->bm_len[state][pos_state],
+								len > 1);
+					else {
+						Re_encode_bit(&encoder->range_encoder,
+								&encoder->bm_rep1[state], dis > 1);
+						if (dis > 1)
+							Re_encode_bit(&encoder->range_encoder,
+									&encoder->bm_rep2[state], dis > 2);
+					}
+					if (len == 1)
+						state = St_set_short_rep(state);
+					else {
+						Lee_encode(&encoder->rep_match_len_encoder,
+								&encoder->range_encoder, len, pos_state);
+						state = St_set_rep(state);
+					}
+				} else {
+					LZe_encode_pair(encoder, dis - num_rep_distances, len,
+									pos_state);
+					state = St_set_match(state);
+				}
+			}
+			ahead -= len;
+			i += len;
+		}
+	}
+	return LZe_full_flush(encoder, state);
+}
+
+
+struct Lzma_options {
+	int dictionary_size;	/* 4KiB..512MiB */
+	int match_len_limit;	/* 5..273 */
+} encoder_options;
+
+
+static int getnum(const char *const ptr, const int llimit, const int ulimit)
+{
+	long result;
+	char *tail;
+
+	errno = 0;
+	result = strtol(ptr, &tail, 0);
+	if (tail == ptr || errno)
+		goto error;
+
+	if (tail[0]) {
+		int factor = (tail[1] == 'i') ? 1024 : 1000;
+		int exponent = 0, i;
+
+		switch (tail[0]) {
+		case 'M':
+			exponent = 2;
+			break;
+		case 'K':
+			if (factor == 1024) {
+				exponent = 1;
+				break;
+			}
+			goto error;
+		case 'k':
+			if (factor == 1000) {
+				exponent = 1;
+				break;
+			}
+		default:
+			goto error;
+		}
+		for (i = 0; i < exponent; ++i) {
+			if (LONG_MAX / factor >= labs(result))
+				result *= factor;
+			else
+				goto error;
+		}
+	}
+	if (result >= llimit && result <= ulimit)
+		return result;
+
+  error:
+	bb_error_msg_and_die("invalid number");
+}
+
+
+static int get_dict_size(const char *const arg)
+{
+	char *tail;
+	long bits = strtol(arg, &tail, 0);
+
+	if (bits >= min_dictionary_bits &&
+		bits <= max_dictionary_bits && *tail == 0)
+		return (1 << bits);
+	return getnum(arg, min_dictionary_size, max_dictionary_size);
+}
+
+
+static IF_DESKTOP(long long) int FAST_FUNC pack_lzip(transformer_aux_data_t * aux UNUSED_PARAM)
+{
+	int retval = 0;
+	File_header header;
+	struct Matchfinder matchfinder;
+	struct LZ_encoder * encoder;
+
+	Fh_set_magic(header);
+	if (!Fh_set_dictionary_size(header, encoder_options.dictionary_size) ||
+		encoder_options.match_len_limit < min_match_len_limit ||
+		encoder_options.match_len_limit > max_match_len)
+		bb_error_msg_and_die("internal error");
+
+	if (!Mf_init(&matchfinder, Fh_get_dictionary_size(header),
+				encoder_options.match_len_limit)) {
+		bb_error_msg(bb_msg_memory_exhausted);
+		return -1;
+	}
+	Fh_set_dictionary_size(header, matchfinder.dictionary_size);
+
+	encoder = malloc(sizeof(struct LZ_encoder));
+	if (!encoder || !LZe_init(encoder, &matchfinder, header)) {
+		bb_error_msg(bb_msg_memory_exhausted);
+		retval = -1;
+	} else {
+		if (!LZe_encode_member(encoder)) {
+			bb_perror_msg(bb_msg_write_error);
+			retval = -1;
+		}
+		LZe_free(encoder);
+	}
+	free(encoder);
+	Mf_free(&matchfinder);
+	return retval;
+}
+
+
+int lzip_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
+int lzip_main(int argc UNUSED_PARAM, char **argv)
+{
+	/* Mapping from gzip/bzip2 style 1..9 compression modes
+	   to the corresponding LZMA compression modes. */
+	const struct Lzma_options option_mapping[] = {
+		{1 << 20, 5},	/* -0 */
+		{1 << 20, 5},	/* -1 */
+		{3 << 19, 6},	/* -2 */
+		{1 << 21, 8},	/* -3 */
+		{3 << 20, 12},	/* -4 */
+		{1 << 22, 20},	/* -5 */
+		{1 << 23, 36},	/* -6 */
+		{1 << 24, 68},	/* -7 */
+		{3 << 23, 132},	/* -8 */
+		{1 << 25, 273}	/* -9 */
+	};
+	int i;
+	char *m_arg;
+	char *s_arg;
+	/* Must match bbunzip's constants OPT_STDOUT, OPT_FORCE! */
+	uint32_t flags = getopt32(argv, "cfv" IF_LUNZIP("dt")
+					"0123456789Fkm:qs:", &m_arg, &s_arg);
+
+#if ENABLE_LUNZIP		/* lunzip_main may not be visible... */
+	if (flags & 0x18)	// -d and/or -t
+		return lunzip_main(argc, argv);
+	flags >>= 5;
+#else
+	flags >>= 3;
+#endif
+
+	encoder_options = option_mapping[6];	/* default = "-6" */
+
+	for (i = 9; i >= 7; --i)
+		if (flags & (1 << i))
+			encoder_options = option_mapping[i];
+	for (i = 0; i <= 6; ++i)
+		if (flags & (1 << i))
+			encoder_options = option_mapping[i];
+	if (flags & (1 << 12))			/* -m */
+		encoder_options.match_len_limit =
+			getnum(m_arg, min_match_len_limit, max_match_len);
+	if (flags & (1 << 14))			/* -s */
+		encoder_options.dictionary_size = get_dict_size(s_arg);
+	/* end process options */
+
+	argv += optind;
+
+	if (!global_crc32_table)
+		global_crc32_table = crc32_filltable(NULL, 0);
+	if(!dis_slots) {
+		Dis_slots_init();
+		Prob_prices_init();
+	}
+
+	return bbunpack(argv, pack_lzip, append_ext, "lz");
+}
diff -urdN busybox-1.20.2.orig/archival/tar.c busybox-1.20.2.new/archival/tar.c
--- busybox-1.20.2.orig/archival/tar.c	2012-07-02 16:08:25.000000000 +0200
+++ busybox-1.20.2.new/archival/tar.c	2012-12-07 18:23:33.000000000 +0100
@@ -695,6 +695,7 @@
 //usage:	IF_FEATURE_SEAMLESS_Z("Z")
 //usage:	IF_FEATURE_SEAMLESS_GZ("z")
 //usage:	IF_FEATURE_SEAMLESS_BZ2("j")
+//usage:	IF_FEATURE_SEAMLESS_LZ("y")
 //usage:	IF_FEATURE_SEAMLESS_LZMA("a")
 //usage:	IF_FEATURE_TAR_CREATE("h")
 //usage:	IF_FEATURE_TAR_NOPRESERVE_TIME("m")
@@ -723,6 +724,9 @@
 //usage:	IF_FEATURE_SEAMLESS_BZ2(
 //usage:     "\n	j	(De)compress using bzip2"
 //usage:	)
+//usage:	IF_FEATURE_SEAMLESS_LZ(
+//usage:     "\n	y	(De)compress using lzip"
+//usage:	)
 //usage:	IF_FEATURE_SEAMLESS_LZMA(
 //usage:     "\n	a	(De)compress using lzma"
 //usage:	)
@@ -766,6 +770,7 @@
 	IF_FEATURE_TAR_FROM(     OPTBIT_EXCLUDE_FROM,)
 	IF_FEATURE_SEAMLESS_GZ(  OPTBIT_GZIP        ,)
 	IF_FEATURE_SEAMLESS_Z(   OPTBIT_COMPRESS    ,) // 16th bit
+	IF_FEATURE_SEAMLESS_LZ(  OPTBIT_LZIP        ,)
 	IF_FEATURE_TAR_NOPRESERVE_TIME(OPTBIT_NOPRESERVE_TIME,)
 #if ENABLE_FEATURE_TAR_LONG_OPTIONS
 	IF_FEATURE_TAR_TO_COMMAND(OPTBIT_2COMMAND   ,)
@@ -789,6 +794,7 @@
 	OPT_INCLUDE_FROM = IF_FEATURE_TAR_FROM(     (1 << OPTBIT_INCLUDE_FROM)) + 0, // T
 	OPT_EXCLUDE_FROM = IF_FEATURE_TAR_FROM(     (1 << OPTBIT_EXCLUDE_FROM)) + 0, // X
 	OPT_GZIP         = IF_FEATURE_SEAMLESS_GZ(  (1 << OPTBIT_GZIP        )) + 0, // z
+	OPT_LZIP         = IF_FEATURE_SEAMLESS_LZ(  (1 << OPTBIT_LZIP        )) + 0, // y
 	OPT_COMPRESS     = IF_FEATURE_SEAMLESS_Z(   (1 << OPTBIT_COMPRESS    )) + 0, // Z
 	OPT_NOPRESERVE_TIME = IF_FEATURE_TAR_NOPRESERVE_TIME((1 << OPTBIT_NOPRESERVE_TIME)) + 0, // m
 	OPT_2COMMAND        = IF_FEATURE_TAR_TO_COMMAND(  (1 << OPTBIT_2COMMAND       )) + 0, // to-command
@@ -796,7 +802,7 @@
 	OPT_NOPRESERVE_PERM = IF_FEATURE_TAR_LONG_OPTIONS((1 << OPTBIT_NOPRESERVE_PERM)) + 0, // no-same-permissions
 	OPT_OVERWRITE       = IF_FEATURE_TAR_LONG_OPTIONS((1 << OPTBIT_OVERWRITE      )) + 0, // overwrite
 
-	OPT_ANY_COMPRESS = (OPT_BZIP2 | OPT_LZMA | OPT_GZIP | OPT_COMPRESS),
+	OPT_ANY_COMPRESS = (OPT_BZIP2 | OPT_LZMA | OPT_GZIP | OPT_LZIP | OPT_COMPRESS),
 };
 #if ENABLE_FEATURE_TAR_LONG_OPTIONS
 static const char tar_longopts[] ALIGN1 =
@@ -829,6 +835,9 @@
 # if ENABLE_FEATURE_SEAMLESS_GZ
 	"gzip\0"                No_argument       "z"
 # endif
+# if ENABLE_FEATURE_SEAMLESS_LZ
+	"lzip\0"                No_argument       "y"
+# endif
 # if ENABLE_FEATURE_SEAMLESS_Z
 	"compress\0"            No_argument       "Z"
 # endif
@@ -921,6 +930,7 @@
 		IF_FEATURE_SEAMLESS_LZMA("a"   )
 		IF_FEATURE_TAR_FROM(     "T:X:")
 		IF_FEATURE_SEAMLESS_GZ(  "z"   )
+		IF_FEATURE_SEAMLESS_LZ(  "y"   )
 		IF_FEATURE_SEAMLESS_Z(   "Z"   )
 		IF_FEATURE_TAR_NOPRESERVE_TIME("m")
 		, &base_dir // -C dir
@@ -1068,6 +1078,9 @@
 		if (opt & OPT_BZIP2)
 			USE_FOR_MMU(xformer = unpack_bz2_stream;)
 			USE_FOR_NOMMU(xformer_prog = "bunzip2";)
+		if (opt & OPT_LZIP)
+			USE_FOR_MMU(xformer = unpack_lz_stream;)
+			USE_FOR_NOMMU(xformer_prog = "lunzip";)
 		if (opt & OPT_LZMA)
 			USE_FOR_MMU(xformer = unpack_lzma_stream;)
 			USE_FOR_NOMMU(xformer_prog = "unlzma";)
diff -urdN busybox-1.20.2.orig/configs/TEST_nommu_defconfig busybox-1.20.2.new/configs/TEST_nommu_defconfig
--- busybox-1.20.2.orig/configs/TEST_nommu_defconfig	2012-07-02 16:08:25.000000000 +0200
+++ busybox-1.20.2.new/configs/TEST_nommu_defconfig	2012-12-07 18:12:58.000000000 +0100
@@ -108,6 +108,7 @@
 CONFIG_FEATURE_SEAMLESS_LZMA=y
 CONFIG_FEATURE_SEAMLESS_BZ2=y
 CONFIG_FEATURE_SEAMLESS_GZ=y
+CONFIG_FEATURE_SEAMLESS_LZ=y
 CONFIG_FEATURE_SEAMLESS_Z=y
 CONFIG_AR=y
 CONFIG_FEATURE_AR_LONG_FILENAMES=y
@@ -122,6 +123,8 @@
 CONFIG_GUNZIP=y
 CONFIG_GZIP=y
 CONFIG_FEATURE_GZIP_LONG_OPTIONS=y
+CONFIG_LUNZIP=y
+CONFIG_LZIP=y
 CONFIG_LZOP=y
 CONFIG_LZOP_COMPR_HIGH=y
 CONFIG_RPM2CPIO=y
diff -urdN busybox-1.20.2.orig/configs/TEST_noprintf_defconfig busybox-1.20.2.new/configs/TEST_noprintf_defconfig
--- busybox-1.20.2.orig/configs/TEST_noprintf_defconfig	2012-07-02 16:08:25.000000000 +0200
+++ busybox-1.20.2.new/configs/TEST_noprintf_defconfig	2012-12-07 18:12:58.000000000 +0100
@@ -119,6 +119,7 @@
 CONFIG_FEATURE_SEAMLESS_LZMA=y
 CONFIG_FEATURE_SEAMLESS_BZ2=y
 CONFIG_FEATURE_SEAMLESS_GZ=y
+CONFIG_FEATURE_SEAMLESS_LZ=y
 CONFIG_FEATURE_SEAMLESS_Z=y
 # CONFIG_AR is not set
 # CONFIG_FEATURE_AR_LONG_FILENAMES is not set
@@ -134,6 +135,8 @@
 # CONFIG_GUNZIP is not set
 # CONFIG_GZIP is not set
 # CONFIG_FEATURE_GZIP_LONG_OPTIONS is not set
+# CONFIG_LUNZIP is not set
+# CONFIG_LZIP is not set
 # CONFIG_LZOP is not set
 # CONFIG_LZOP_COMPR_HIGH is not set
 # CONFIG_RPM2CPIO is not set
diff -urdN busybox-1.20.2.orig/configs/TEST_rh9_defconfig busybox-1.20.2.new/configs/TEST_rh9_defconfig
--- busybox-1.20.2.orig/configs/TEST_rh9_defconfig	2012-07-02 16:08:25.000000000 +0200
+++ busybox-1.20.2.new/configs/TEST_rh9_defconfig	2012-12-07 18:12:58.000000000 +0100
@@ -117,6 +117,7 @@
 CONFIG_FEATURE_SEAMLESS_LZMA=y
 CONFIG_FEATURE_SEAMLESS_BZ2=y
 CONFIG_FEATURE_SEAMLESS_GZ=y
+CONFIG_FEATURE_SEAMLESS_LZ=y
 CONFIG_FEATURE_SEAMLESS_Z=y
 CONFIG_AR=y
 CONFIG_FEATURE_AR_LONG_FILENAMES=y
@@ -132,6 +133,8 @@
 CONFIG_GUNZIP=y
 CONFIG_GZIP=y
 CONFIG_FEATURE_GZIP_LONG_OPTIONS=y
+CONFIG_LUNZIP=y
+CONFIG_LZIP=y
 CONFIG_LZOP=y
 # CONFIG_LZOP_COMPR_HIGH is not set
 CONFIG_RPM2CPIO=y
diff -urdN busybox-1.20.2.orig/configs/android2_defconfig busybox-1.20.2.new/configs/android2_defconfig
--- busybox-1.20.2.orig/configs/android2_defconfig	2012-07-02 16:08:25.000000000 +0200
+++ busybox-1.20.2.new/configs/android2_defconfig	2012-12-07 18:12:58.000000000 +0100
@@ -124,6 +124,7 @@
 CONFIG_FEATURE_SEAMLESS_LZMA=y
 CONFIG_FEATURE_SEAMLESS_BZ2=y
 CONFIG_FEATURE_SEAMLESS_GZ=y
+CONFIG_FEATURE_SEAMLESS_LZ=y
 CONFIG_FEATURE_SEAMLESS_Z=y
 CONFIG_AR=y
 CONFIG_FEATURE_AR_LONG_FILENAMES=y
@@ -139,6 +140,8 @@
 CONFIG_GUNZIP=y
 CONFIG_GZIP=y
 # CONFIG_FEATURE_GZIP_LONG_OPTIONS is not set
+CONFIG_LUNZIP=y
+CONFIG_LZIP=y
 CONFIG_LZOP=y
 CONFIG_LZOP_COMPR_HIGH=y
 CONFIG_RPM2CPIO=y
diff -urdN busybox-1.20.2.orig/configs/android_defconfig busybox-1.20.2.new/configs/android_defconfig
--- busybox-1.20.2.orig/configs/android_defconfig	2012-07-02 16:08:25.000000000 +0200
+++ busybox-1.20.2.new/configs/android_defconfig	2012-12-07 18:12:58.000000000 +0100
@@ -144,6 +144,7 @@
 CONFIG_FEATURE_SEAMLESS_LZMA=y
 CONFIG_FEATURE_SEAMLESS_BZ2=y
 CONFIG_FEATURE_SEAMLESS_GZ=y
+CONFIG_FEATURE_SEAMLESS_LZ=y
 CONFIG_FEATURE_SEAMLESS_Z=y
 CONFIG_AR=y
 CONFIG_FEATURE_AR_LONG_FILENAMES=y
@@ -160,6 +161,8 @@
 CONFIG_GZIP=y
 # CONFIG_FEATURE_GZIP_LONG_OPTIONS is not set
 CONFIG_GZIP_FAST=0
+CONFIG_LUNZIP=y
+CONFIG_LZIP=y
 CONFIG_LZOP=y
 CONFIG_LZOP_COMPR_HIGH=y
 CONFIG_RPM2CPIO=y
diff -urdN busybox-1.20.2.orig/configs/android_ndk_defconfig busybox-1.20.2.new/configs/android_ndk_defconfig
--- busybox-1.20.2.orig/configs/android_ndk_defconfig	2012-07-02 16:08:25.000000000 +0200
+++ busybox-1.20.2.new/configs/android_ndk_defconfig	2012-12-07 18:12:58.000000000 +0100
@@ -130,6 +130,7 @@
 CONFIG_FEATURE_SEAMLESS_LZMA=y
 CONFIG_FEATURE_SEAMLESS_BZ2=y
 CONFIG_FEATURE_SEAMLESS_GZ=y
+CONFIG_FEATURE_SEAMLESS_LZ=y
 CONFIG_FEATURE_SEAMLESS_Z=y
 CONFIG_AR=y
 CONFIG_FEATURE_AR_LONG_FILENAMES=y
@@ -146,6 +147,8 @@
 CONFIG_GZIP=y
 # CONFIG_FEATURE_GZIP_LONG_OPTIONS is not set
 CONFIG_GZIP_FAST=0
+CONFIG_LUNZIP=y
+CONFIG_LZIP=y
 CONFIG_LZOP=y
 CONFIG_LZOP_COMPR_HIGH=y
 CONFIG_RPM2CPIO=y
diff -urdN busybox-1.20.2.orig/configs/cygwin_defconfig busybox-1.20.2.new/configs/cygwin_defconfig
--- busybox-1.20.2.orig/configs/cygwin_defconfig	2012-07-02 16:08:25.000000000 +0200
+++ busybox-1.20.2.new/configs/cygwin_defconfig	2012-12-07 18:12:58.000000000 +0100
@@ -124,6 +124,7 @@
 CONFIG_FEATURE_SEAMLESS_LZMA=y
 CONFIG_FEATURE_SEAMLESS_BZ2=y
 CONFIG_FEATURE_SEAMLESS_GZ=y
+CONFIG_FEATURE_SEAMLESS_LZ=y
 # CONFIG_FEATURE_SEAMLESS_Z is not set
 # CONFIG_AR is not set
 # CONFIG_FEATURE_AR_LONG_FILENAMES is not set
@@ -139,6 +140,8 @@
 CONFIG_GUNZIP=y
 CONFIG_GZIP=y
 CONFIG_FEATURE_GZIP_LONG_OPTIONS=y
+CONFIG_LUNZIP=y
+CONFIG_LZIP=y
 CONFIG_LZOP=y
 # CONFIG_LZOP_COMPR_HIGH is not set
 CONFIG_RPM2CPIO=y
diff -urdN busybox-1.20.2.orig/configs/freebsd_defconfig busybox-1.20.2.new/configs/freebsd_defconfig
--- busybox-1.20.2.orig/configs/freebsd_defconfig	2012-07-02 16:08:25.000000000 +0200
+++ busybox-1.20.2.new/configs/freebsd_defconfig	2012-12-07 18:12:58.000000000 +0100
@@ -121,6 +121,7 @@
 CONFIG_FEATURE_SEAMLESS_LZMA=y
 CONFIG_FEATURE_SEAMLESS_BZ2=y
 CONFIG_FEATURE_SEAMLESS_GZ=y
+CONFIG_FEATURE_SEAMLESS_LZ=y
 CONFIG_FEATURE_SEAMLESS_Z=y
 CONFIG_AR=y
 CONFIG_FEATURE_AR_LONG_FILENAMES=y
@@ -136,6 +137,8 @@
 CONFIG_GUNZIP=y
 CONFIG_GZIP=y
 CONFIG_FEATURE_GZIP_LONG_OPTIONS=y
+CONFIG_LUNZIP=y
+CONFIG_LZIP=y
 CONFIG_LZOP=y
 # CONFIG_LZOP_COMPR_HIGH is not set
 CONFIG_RPM2CPIO=y
diff -urdN busybox-1.20.2.orig/include/applets.src.h busybox-1.20.2.new/include/applets.src.h
--- busybox-1.20.2.orig/include/applets.src.h	2012-07-02 16:08:25.000000000 +0200
+++ busybox-1.20.2.new/include/applets.src.h	2012-12-07 18:12:58.000000000 +0100
@@ -230,7 +230,9 @@
 IF_LSATTR(APPLET(lsattr, BB_DIR_BIN, BB_SUID_DROP))
 IF_LSPCI(APPLET(lspci, BB_DIR_USR_BIN, BB_SUID_DROP))
 IF_LSUSB(APPLET(lsusb, BB_DIR_USR_BIN, BB_SUID_DROP))
+IF_LUNZIP(APPLET(lunzip, BB_DIR_USR_BIN, BB_SUID_DROP))
 IF_UNLZMA(APPLET_ODDNAME(lzcat, unlzma, BB_DIR_USR_BIN, BB_SUID_DROP, lzcat))
+IF_LZIP(APPLET(lzip, BB_DIR_USR_BIN, BB_SUID_DROP))
 IF_LZMA(APPLET_ODDNAME(lzma, unlzma, BB_DIR_USR_BIN, BB_SUID_DROP, lzma))
 IF_LZOP(APPLET(lzop, BB_DIR_BIN, BB_SUID_DROP))
 IF_LZOP(APPLET_ODDNAME(lzopcat, lzop, BB_DIR_USR_BIN, BB_SUID_DROP, lzopcat))
diff -urdN busybox-1.20.2.orig/include/bb_archive.h busybox-1.20.2.new/include/bb_archive.h
--- busybox-1.20.2.orig/include/bb_archive.h	2012-07-02 16:08:25.000000000 +0200
+++ busybox-1.20.2.new/include/bb_archive.h	2012-12-07 18:12:58.000000000 +0100
@@ -9,6 +9,8 @@
 	COMPRESS_MAGIC = 0x1f9d,
 	GZIP_MAGIC  = 0x1f8b,
 	BZIP2_MAGIC = 256 * 'B' + 'Z',
+	LZIP_MAGIC1 = 0x4C5A,
+	LZIP_MAGIC2 = 0x4950,
 	/* .xz signature: 0xfd, '7', 'z', 'X', 'Z', 0x00 */
 	/* More info at: http://tukaani.org/xz/xz-file-format.txt */
 	XZ_MAGIC1   = 256 * 0xfd + '7',
@@ -21,6 +23,8 @@
 	COMPRESS_MAGIC = 0x9d1f,
 	GZIP_MAGIC  = 0x8b1f,
 	BZIP2_MAGIC = 'B' + 'Z' * 256,
+	LZIP_MAGIC1 = 0x5A4C,
+	LZIP_MAGIC2 = 0x5049,
 	XZ_MAGIC1   = 0xfd + '7' * 256,
 	XZ_MAGIC2   = 'z' + ('X' + ('Z' + 0 * 256) * 256) * 256,
 	XZ_MAGIC1a  = 0xfd + ('7' + ('z' + 'X' * 256) * 256) * 256,
@@ -179,6 +183,7 @@
 char get_header_tar(archive_handle_t *archive_handle) FAST_FUNC;
 char get_header_tar_gz(archive_handle_t *archive_handle) FAST_FUNC;
 char get_header_tar_bz2(archive_handle_t *archive_handle) FAST_FUNC;
+char get_header_tar_lz(archive_handle_t *archive_handle) FAST_FUNC;
 char get_header_tar_lzma(archive_handle_t *archive_handle) FAST_FUNC;
 
 void seek_by_jump(int fd, off_t amount) FAST_FUNC;
@@ -214,6 +219,7 @@
 IF_DESKTOP(long long) int unpack_Z_stream(transformer_aux_data_t *aux, int src_fd, int dst_fd) FAST_FUNC;
 IF_DESKTOP(long long) int unpack_gz_stream(transformer_aux_data_t *aux, int src_fd, int dst_fd) FAST_FUNC;
 IF_DESKTOP(long long) int unpack_bz2_stream(transformer_aux_data_t *aux, int src_fd, int dst_fd) FAST_FUNC;
+IF_DESKTOP(long long) int unpack_lz_stream(transformer_aux_data_t *aux, int src_fd, int dst_fd) FAST_FUNC;
 IF_DESKTOP(long long) int unpack_lzma_stream(transformer_aux_data_t *aux, int src_fd, int dst_fd) FAST_FUNC;
 IF_DESKTOP(long long) int unpack_xz_stream(transformer_aux_data_t *aux, int src_fd, int dst_fd) FAST_FUNC;
 
diff -urdN busybox-1.20.2.orig/include/libbb.h busybox-1.20.2.new/include/libbb.h
--- busybox-1.20.2.orig/include/libbb.h	2012-07-02 16:08:25.000000000 +0200
+++ busybox-1.20.2.new/include/libbb.h	2012-12-07 18:12:58.000000000 +0100
@@ -717,12 +717,13 @@
 #define SEAMLESS_COMPRESSION (0 \
  || ENABLE_FEATURE_SEAMLESS_XZ \
  || ENABLE_FEATURE_SEAMLESS_LZMA \
+ || ENABLE_FEATURE_SEAMLESS_LZ \
  || ENABLE_FEATURE_SEAMLESS_BZ2 \
  || ENABLE_FEATURE_SEAMLESS_GZ \
  || ENABLE_FEATURE_SEAMLESS_Z)
 
 #if SEAMLESS_COMPRESSION
-/* Autodetects gzip/bzip2 formats. fd may be in the middle of the file! */
+/* Autodetects gzip/bzip2/lzip formats. fd may be in the middle of the file! */
 extern int setup_unzip_on_fd(int fd, int fail_if_not_detected) FAST_FUNC;
 /* Autodetects .gz etc */
 extern int open_zipped(const char *fname) FAST_FUNC;
@@ -1100,6 +1101,7 @@
 /* Don't need IF_xxx() guard for these */
 int gunzip_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
 int bunzip2_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
+int lunzip_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
 
 #if ENABLE_ROUTE
 void bb_displayroutes(int noresolve, int netstatfmt) FAST_FUNC;
diff -urdN busybox-1.20.2.orig/loginutils/passwd.c busybox-1.20.2.new/loginutils/passwd.c
--- busybox-1.20.2.orig/loginutils/passwd.c	2012-06-26 15:35:45.000000000 +0200
+++ busybox-1.20.2.new/loginutils/passwd.c	2012-12-07 17:42:14.000000000 +0100
@@ -15,6 +15,7 @@
 
 #include "libbb.h"
 #include <syslog.h>
+#include <sys/resource.h>	/* rlimit */
 
 static void nuke_str(char *str)
 {
diff -urdN busybox-1.20.2.orig/miscutils/man.c busybox-1.20.2.new/miscutils/man.c
--- busybox-1.20.2.orig/miscutils/man.c	2012-07-02 16:19:22.000000000 +0200
+++ busybox-1.20.2.new/miscutils/man.c	2012-12-07 18:12:58.000000000 +0100
@@ -132,6 +132,11 @@
 	if (run_pipe(pager, filename_with_zext, man, level))
 		return 1;
 #endif
+#if ENABLE_FEATURE_SEAMLESS_LZ
+	strcpy(ext, "lz");
+	if (run_pipe(pager, filename_with_zext, man, level))
+		return 1;
+#endif
 #if ENABLE_FEATURE_SEAMLESS_BZ2
 	strcpy(ext, "bz2");
 	if (run_pipe(pager, filename_with_zext, man, level))
diff -urdN busybox-1.20.2.orig/miscutils/time.c busybox-1.20.2.new/miscutils/time.c
--- busybox-1.20.2.orig/miscutils/time.c	2012-06-26 15:35:45.000000000 +0200
+++ busybox-1.20.2.new/miscutils/time.c	2012-12-07 17:47:23.000000000 +0100
@@ -16,6 +16,7 @@
 //usage:     "\n	-v	Verbose"
 
 #include "libbb.h"
+#include <sys/resource.h>	/* rusage */
 
 /* Information on the resources used by a child process.  */
 typedef struct {
diff -urdN busybox-1.20.2.orig/networking/inetd.c busybox-1.20.2.new/networking/inetd.c
--- busybox-1.20.2.orig/networking/inetd.c	2012-07-02 16:08:25.000000000 +0200
+++ busybox-1.20.2.new/networking/inetd.c	2012-12-07 17:49:10.000000000 +0100
@@ -166,6 +166,7 @@
 
 #include <syslog.h>
 #include <sys/un.h>
+#include <sys/resource.h>	/* rlimit */
 
 #include "libbb.h"
 
diff -urdN busybox-1.20.2.orig/networking/ntpd.c busybox-1.20.2.new/networking/ntpd.c
--- busybox-1.20.2.orig/networking/ntpd.c	2012-07-02 16:08:25.000000000 +0200
+++ busybox-1.20.2.new/networking/ntpd.c	2012-12-07 18:02:49.000000000 +0100
@@ -46,6 +46,7 @@
 #include "libbb.h"
 #include <math.h>
 #include <netinet/ip.h> /* For IPTOS_LOWDELAY definition */
+#include <sys/resource.h>	/* setpriority */
 #include <sys/timex.h>
 #ifndef IPTOS_LOWDELAY
 # define IPTOS_LOWDELAY 0x10
diff -urdN busybox-1.20.2.orig/runit/chpst.c busybox-1.20.2.new/runit/chpst.c
--- busybox-1.20.2.orig/runit/chpst.c	2012-06-26 15:35:45.000000000 +0200
+++ busybox-1.20.2.new/runit/chpst.c	2012-12-07 18:04:32.000000000 +0100
@@ -90,6 +90,7 @@
 //usage:     "\n	-t N		Limit CPU time, process receives"
 //usage:     "\n			a SIGXCPU after N seconds"
 
+#include <sys/resource.h>	/* rlimit */
 #include "libbb.h"
 
 /*
diff -urdN busybox-1.20.2.orig/shell/shell_common.c busybox-1.20.2.new/shell/shell_common.c
--- busybox-1.20.2.orig/shell/shell_common.c	2012-06-26 15:35:45.000000000 +0200
+++ busybox-1.20.2.new/shell/shell_common.c	2012-12-07 18:05:37.000000000 +0100
@@ -16,6 +16,7 @@
  *
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
+#include <sys/resource.h>	/* rlimit */
 #include "libbb.h"
 #include "shell_common.h"
 
diff -urdN busybox-1.20.2.orig/testsuite/bunzip2.tests busybox-1.20.2.new/testsuite/bunzip2.tests
--- busybox-1.20.2.orig/testsuite/bunzip2.tests	2012-06-26 15:35:45.000000000 +0200
+++ busybox-1.20.2.new/testsuite/bunzip2.tests	2012-12-07 18:12:58.000000000 +0100
@@ -9,6 +9,9 @@
 elif test "${0##*/}" = "bunzip2.tests"; then
     unpack=bunzip2
     ext=bz2
+elif test "${0##*/}" = "lunzip.tests"; then
+    unpack=lunzip
+    ext=lz
 else
     echo "WTF? argv0='$0'"
     exit 1
@@ -35,6 +38,13 @@
 $ECHO -ne "\x17\x72\x45\x38\x50\x90\x5b\xb8\xe8\xa3"
 }
 
+hello_lz() {
+# Lzipped "HELLO\n"
+$ECHO -ne "\x4c\x5a\x49\x50\x01\x0c\x00\x24\x11\x45\xcf\x72\xcd\x3d\x3a\xdf"
+$ECHO -ne "\xff\xff\xdd\x12\x00\x00\x6e\xd7\xac\xfd\x06\x00\x00\x00\x00\x00"
+$ECHO -ne "\x00\x00\x2a\x00\x00\x00\x00\x00\x00\x00"
+}
+
 # We had bunzip2 error on this .bz2 file (fixed in rev 22521)
 test1_bz2()
 {
@@ -530,6 +540,12 @@
 expected="ok\n"
 prep; check "$unpack: delete src" "${bb}$unpack t2.$ext; test ! -f t2.$ext && echo ok"
 
+expected="ok\n"
+rm -f t1.*
+hello_$ext > t1.t$ext
+check "$unpack: replace .t$ext --> .tar" \
+"${bb}$unpack t1.t$ext && test -f t1.tar && test ! -f t1.t$ext && echo ok"
+
 )
 rm -rf testdir
 
diff -urdN busybox-1.20.2.orig/testsuite/lunzip.tests busybox-1.20.2.new/testsuite/lunzip.tests
--- busybox-1.20.2.orig/testsuite/lunzip.tests	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.20.2.new/testsuite/lunzip.tests	2012-12-07 18:12:58.000000000 +0100
@@ -0,0 +1,3 @@
+#!/bin/sh
+
+. ./bunzip2.tests
diff -urdN busybox-1.20.2.orig/testsuite/lzip.tests busybox-1.20.2.new/testsuite/lzip.tests
--- busybox-1.20.2.orig/testsuite/lzip.tests	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.20.2.new/testsuite/lzip.tests	2012-12-07 18:12:58.000000000 +0100
@@ -0,0 +1,58 @@
+#!/bin/sh
+# Copyright (C) 2012 Antonio Diaz Diaz
+# Licensed under GPLv2, see file LICENSE in this source tree.
+
+. ./testing.sh
+
+rm -rf lzip.testdir 2>/dev/null
+mkdir lzip.testdir
+
+# Lzipped "a"
+$ECHO -ne "\x4c\x5a\x49\x50\x01\x0c\x00\x30\xc1\xfb\xff\xff\xff\xe0\x00\x00\
+\x00\x43\xbe\xb7\xe8\x01\x00\x00\x00\x00\x00\x00\x00\x25\x00\x00\
+\x00\x00\x00\x00\x00" > lzip.testdir/a.lz
+
+# Lzipped zero-length file
+$ECHO -ne "\x4c\x5a\x49\x50\x01\x0c\x00\x83\xff\xfb\xff\xff\xc0\x00\x00\x00\
+\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x24\x00\x00\x00\
+\x00\x00\x00\x00" > lzip.testdir/zero.lz
+
+
+# testing "test name" "commands" "expected result" "file input" "stdin"
+
+testing "lzip reads from standard input" \
+"busybox lzip | cmp lzip.testdir/a.lz -" "" "" "a"
+
+testing "lzip accepts single minus" \
+"busybox lzip - | cmp lzip.testdir/a.lz -" "" "" "a"
+
+testing "lzip compresses a zero-length file" \
+"> zero ; busybox lzip -c zero | cmp lzip.testdir/zero.lz -" "" "" ""
+
+testing "lzip replaces original file" \
+"$ECHO foo > lzip.testdir/foo
+rm -f lzip.testdir/foo.lz 2>/dev/null
+busybox lzip lzip.testdir/foo
+test -f lzip.testdir/foo.lz && test ! -f lzip.testdir/foo && echo ok" \
+"ok\n" "" ""
+
+testing "lzip replaces multiple files" \
+"$ECHO foo > lzip.testdir/foo
+$ECHO bar > lzip.testdir/bar
+rm -f lzip.testdir/foo.lz 2>/dev/null
+rm -f lzip.testdir/bar.lz 2>/dev/null
+busybox lzip lzip.testdir/foo lzip.testdir/bar
+test -f lzip.testdir/foo.lz && test ! -f lzip.testdir/foo && echo ok1
+test -f lzip.testdir/bar.lz && test ! -f lzip.testdir/bar && echo ok2" \
+"ok1\nok2\n" "" ""
+
+testing "lzip -c does not remove original file" \
+"$ECHO foo > lzip.testdir/foo
+busybox lzip -c lzip.testdir/foo >/dev/null
+test -f lzip.testdir/foo && echo ok" "ok\n" "" ""
+
+
+# Clean up
+rm -rf lzip.testdir 2>/dev/null
+
+exit $FAILCOUNT
diff -urdN busybox-1.20.2.orig/testsuite/tar.tests busybox-1.20.2.new/testsuite/tar.tests
--- busybox-1.20.2.orig/testsuite/tar.tests	2012-06-26 15:35:45.000000000 +0200
+++ busybox-1.20.2.new/testsuite/tar.tests	2012-12-07 18:12:58.000000000 +0100
@@ -170,6 +170,25 @@
 "" ""
 SKIP=
 
+# lzipped tar archive with a file named ustar containing "ustar\n"
+optional FEATURE_SEAMLESS_LZ
+testing "tar extract tlz" "\
+tar -xyvf - && echo Ok
+rm ustar || echo BAD
+" "\
+ustar
+Ok
+" \
+"" "\
+\x4c\x5a\x49\x50\x01\x0c\x00\x3a\x9c\xca\xdd\xdf\xd4\xd1\x20\x5c\
+\xd8\x09\x8b\x76\xed\xd4\xe3\x53\xc0\x91\x33\x1e\x8c\x70\xfe\x9a\
+\xb3\xd9\xab\xbf\x33\xd0\x4e\x42\x90\xee\xa0\xad\xa7\xa3\x8c\xa9\
+\xfb\x94\xce\xf9\xdc\x54\x68\x12\x1d\x1b\x42\x36\x10\x5a\xa9\x15\
+\x59\x4c\x46\xae\x50\xa5\xe7\xe2\x8d\xc0\xf5\x4b\xa3\xfa\xb7\x15\
+\x6e\x33\x92\xc0\x93\xff\xff\xf7\x6b\x7b\x00\x2e\xb1\xb8\xc0\x00\
+\x08\x00\x00\x00\x00\x00\x00\x6f\x00\x00\x00\x00\x00\x00\x00"
+SKIP=
+
 # Do we detect XZ-compressed data (even w/o .tar.xz or txz extension)?
 # (the uuencoded hello_world.txz contains one empty file named "hello_world")
 optional UUDECODE FEATURE_TAR_AUTODETECT FEATURE_SEAMLESS_XZ
